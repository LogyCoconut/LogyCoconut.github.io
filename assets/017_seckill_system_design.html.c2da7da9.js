import{_ as i}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as r,c as n,a as e,b as o,d as a,e as t,r as c}from"./app.d83cf222.js";const d={},s=e("li",null,"基于秒杀场景的Java高并发实现",-1),h=e("li",null,"对秒杀场景的方案设计",-1),u={href:"https://github.com/logycoconut/springboot-seckill",target:"_blank",rel:"noopener noreferrer"},p=t('<h2 id="技术体系" tabindex="-1"><a class="header-anchor" href="#技术体系" aria-hidden="true">#</a> 技术体系</h2><ul><li><p>前端: <code>Bootstrap</code> + <code>jQuery</code></p></li><li><p>后端: <code>SpringBoot2</code> + <code>MyBatisPlus</code> + <code>MySQL</code></p></li><li><p>中间件技术: <code>Redis</code> + <code>RabbitMQ</code> + <code>JWT</code></p></li></ul><h2 id="秒杀场景以及解决方案" tabindex="-1"><a class="header-anchor" href="#秒杀场景以及解决方案" aria-hidden="true">#</a> 秒杀场景以及解决方案</h2><h3 id="高并发" tabindex="-1"><a class="header-anchor" href="#高并发" aria-hidden="true">#</a> 高并发</h3><blockquote><p>在传统WEB应用中, 每次请求都是对数据库的一次访问; 但是在秒杀场景下, 流量会在瞬间达到上万以上, 这么多请求要是都流向数据库, 数据库立马就会挂掉 秒杀活动被迫中断</p></blockquote><p>所以我们应该尽量将请求拦截在上游, 对请求进行限流</p><p><strong>前端限流 :</strong></p><ul><li>秒杀前将秒杀按钮置灰 ( 即不可点击的状态 )</li><li>秒杀时限制点击频率, 例如每秒最多点击一次</li></ul><p><strong>后端限流 :</strong></p><ul><li>令牌桶算法限流, 例如 <code>Guava</code> 的 <code>RateLimiter</code>, 就是以固定的频率向桶中放入令牌, 每次秒杀前都从桶中获取令牌, 取到令牌后才能进入下一步, 否则返回错误代码</li></ul><p><strong>库存预热</strong></p><ul><li>在服务启动时将秒杀相关信息都加载到<code>Redis</code>中, 商品库存的删减都在<code>Redis</code>中进行</li></ul><p><strong>消息队列</strong></p><ul><li>用户只关心当时是否成功秒杀, 对于后台数据库真实库存的变化以及订单创建快慢并不敏感</li><li>运行消息队列缓冲过量流量, 将同步操作转换成异步推送, 在队列的另一端平滑地将消息推送出去, 平稳的对数据库进行访问</li></ul><p><strong>资源静态化</strong></p><ul><li>不再需要服务器渲染好页面然后传到浏览器, 而是由静态页面来请求数据</li></ul><h3 id="超卖" tabindex="-1"><a class="header-anchor" href="#超卖" aria-hidden="true">#</a> 超卖</h3><ul><li>对商品库存加乐观锁</li></ul><h3 id="链接暴露" tabindex="-1"><a class="header-anchor" href="#链接暴露" aria-hidden="true">#</a> 链接暴露</h3><ul><li>秒杀链接的提前暴露可能会导致有人绕过业务直接请求接口,为了防止这种情况发生, 我们可以采取URL动态化的方式</li><li><strong>具体实现思路 :</strong> 在秒杀开始之前, 先获取秒杀地址, 再根据秒杀地址进行秒杀</li></ul><h3 id="恶意请求" tabindex="-1"><a class="header-anchor" href="#恶意请求" aria-hidden="true">#</a> 恶意请求</h3><ul><li>采取验证码的方式防止大量重复请求, 同时也可以分担流量压力</li></ul><h2 id="致谢" tabindex="-1"><a class="header-anchor" href="#致谢" aria-hidden="true">#</a> 致谢</h2>',23),_={href:"https://github.com/zaiyunduan123/springboot-sckill",target:"_blank",rel:"noopener noreferrer"},b={href:"https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453145142&idx=1&sn=3a25d7caf7135a64112e4f9ac2224a9e&chksm=8cfd24b5bb8aada34295666b6b4eace58efa44cd2a9f07c06ca2a61242583e83cea3d1b98143&scene=158#rd",target:"_blank",rel:"noopener noreferrer"};function g(f,m){const l=c("ExternalLinkIcon");return r(),n("div",null,[e("blockquote",null,[e("ul",null,[s,h,e("li",null,[o("仓库地址: "),e("a",u,[o("https://github.com/logycoconut/springboot-seckill"),a(l)])])])]),p,e("ul",null,[e("li",null,[e("p",null,[o("本项目是对 "),e("a",_,[o("zaiyunduan123/springboot-seckill"),a(l)]),o(" 的二次开发, 在项目初期给了我很大的启发")])]),e("li",null,[e("p",null,[o("在后期寻求再次优化的时候, 敖丙的文章也让我对秒杀系统的整体架构有了更清楚的认知, "),e("a",b,[o("敖丙带你设计【秒杀系统】"),a(l)])])])])])}const y=i(d,[["render",g],["__file","017_seckill_system_design.html.vue"]]);export{y as default};
