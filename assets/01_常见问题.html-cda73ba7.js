const t=JSON.parse('{"key":"v-c3e25890","path":"/Resource/code/01_java/02_%E9%9B%86%E5%90%88/01_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html","title":"常见问题","lang":"zh-CN","frontmatter":{"title":"常见问题","date":"2022-02-26T00:00:00.000Z","tag":["Java"],"description":"ArrayList 和 LinkedList 的区别 是否保证线程安全：二者都是不同步的，都不保证线程安全 底层数据结构：ArrayList 底层是 Object[]数组；LinkedList 底层用的是双向链表 插入和删除是否受元素位置的影响： ArrayList 采用数组存储，所以插入和删除元素受元素位置的影响 比如：执行 add(E e)方法时，会默认将指定的元素追加到此列表的末尾，这种时间复杂度就是 O(1)，但是如果要在指定位置增加元素的话，时间复杂度就是 O(n-i)，因为其余位置的元素都需要向后移动一位 LinkedList 采用链表存储，所以对于 add(E e)方法来说，复杂度也近似 O(1)，如果是要在指定位置插入元素的话，时间复杂度就近似 O(n)，因为需要先移动到指定位置 是否支持快速随机访问：ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素 内存空间占用：ArrayList 的空间浪费主要体现在 list 的结尾会预留一定的容量空间，而 LinkedList 的空间话费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继、直接前驱以及数据）","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/Resource/code/01_java/02_%E9%9B%86%E5%90%88/01_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"}],["meta",{"property":"og:title","content":"常见问题"}],["meta",{"property":"og:description","content":"ArrayList 和 LinkedList 的区别 是否保证线程安全：二者都是不同步的，都不保证线程安全 底层数据结构：ArrayList 底层是 Object[]数组；LinkedList 底层用的是双向链表 插入和删除是否受元素位置的影响： ArrayList 采用数组存储，所以插入和删除元素受元素位置的影响 比如：执行 add(E e)方法时，会默认将指定的元素追加到此列表的末尾，这种时间复杂度就是 O(1)，但是如果要在指定位置增加元素的话，时间复杂度就是 O(n-i)，因为其余位置的元素都需要向后移动一位 LinkedList 采用链表存储，所以对于 add(E e)方法来说，复杂度也近似 O(1)，如果是要在指定位置插入元素的话，时间复杂度就近似 O(n)，因为需要先移动到指定位置 是否支持快速随机访问：ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素 内存空间占用：ArrayList 的空间浪费主要体现在 list 的结尾会预留一定的容量空间，而 LinkedList 的空间话费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继、直接前驱以及数据）"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-10T10:26:50.000Z"}],["meta",{"property":"article:author","content":"logycoconut"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2022-02-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-10T10:26:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"常见问题\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-02-26T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-10T10:26:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://github.com/logycoconut\\"}]}"]]},"headers":[{"level":2,"title":"ArrayList 和 LinkedList 的区别","slug":"arraylist-和-linkedlist-的区别","link":"#arraylist-和-linkedlist-的区别","children":[{"level":3,"title":"RandomAccess接口","slug":"randomaccess接口","link":"#randomaccess接口","children":[]}]},{"level":2,"title":"ArrayList的扩容机制","slug":"arraylist的扩容机制","link":"#arraylist的扩容机制","children":[{"level":3,"title":"ArrayList的构造函数","slug":"arraylist的构造函数","link":"#arraylist的构造函数","children":[]},{"level":3,"title":"代码解析（Java8）","slug":"代码解析-java8","link":"#代码解析-java8","children":[]},{"level":3,"title":"System.arraycpoy()和 Arrays.copyOf()方法","slug":"system-arraycpoy-和-arrays-copyof-方法","link":"#system-arraycpoy-和-arrays-copyof-方法","children":[]},{"level":3,"title":"ensureCapacity 和 ensureCapacityInternal","slug":"ensurecapacity-和-ensurecapacityinternal","link":"#ensurecapacity-和-ensurecapacityinternal","children":[]}]},{"level":2,"title":"HashMap 与 HashTable 的区别","slug":"hashmap-与-hashtable-的区别","link":"#hashmap-与-hashtable-的区别","children":[{"level":3,"title":"tableSizeFor 保证 HashMap 的大小总为 2 的幂次方","slug":"tablesizefor-保证-hashmap-的大小总为-2-的幂次方","link":"#tablesizefor-保证-hashmap-的大小总为-2-的幂次方","children":[]}]},{"level":2,"title":"HashMap和HashSet的区别","slug":"hashmap和hashset的区别","link":"#hashmap和hashset的区别","children":[]},{"level":2,"title":"HashMap的底层实现","slug":"hashmap的底层实现","link":"#hashmap的底层实现","children":[]},{"level":2,"title":"HashMap的长度为什么是2的幂次方","slug":"hashmap的长度为什么是2的幂次方","link":"#hashmap的长度为什么是2的幂次方","children":[]},{"level":2,"title":"HashMap 多线程操作导致死循环（Java8之前）","slug":"hashmap-多线程操作导致死循环-java8之前","link":"#hashmap-多线程操作导致死循环-java8之前","children":[]},{"level":2,"title":"ConcurrentHashMap 线程安全的具体实现方式","slug":"concurrenthashmap-线程安全的具体实现方式","link":"#concurrenthashmap-线程安全的具体实现方式","children":[]}],"git":{"createdTime":1702204010000,"updatedTime":1702204010000,"contributors":[{"name":"logycoconut","email":"logycoconut@foxmail.com","commits":1}]},"readingTime":{"minutes":7.3,"words":2189},"filePathRelative":"Resource/code/01_java/02_集合/01_常见问题.md","localizedDate":"2022年2月26日","excerpt":"<h2> ArrayList 和 LinkedList 的区别</h2>\\n<ul>\\n<li>\\n<p><strong>是否保证线程安全</strong>：二者都是不同步的，都不保证线程安全</p>\\n</li>\\n<li>\\n<p><strong>底层数据结构</strong>：ArrayList 底层是 Object[]数组；LinkedList 底层用的是双向链表</p>\\n</li>\\n<li>\\n<p><strong>插入和删除是否受元素位置的影响</strong>：</p>\\n<ul>\\n<li>ArrayList 采用数组存储，所以插入和删除元素受元素位置的影响</li>\\n</ul>\\n<p>比如：执行 add(E e)方法时，会默认将指定的元素追加到此列表的末尾，这种时间复杂度就是 O(1)，但是如果要在指定位置增加元素的话，时间复杂度就是 O(n-i)，因为其余位置的元素都需要向后移动一位</p>\\n<ul>\\n<li>LinkedList 采用链表存储，所以对于 add(E e)方法来说，复杂度也近似 O(1)，如果是要在指定位置插入元素的话，时间复杂度就近似 O(n)，因为需要先移动到指定位置</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>是否支持快速随机访问</strong>：ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素</p>\\n</li>\\n<li>\\n<p><strong>内存空间占用</strong>：ArrayList 的空间浪费主要体现在 list 的结尾会预留一定的容量空间，而 LinkedList 的空间话费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继、直接前驱以及数据）</p>\\n</li>\\n</ul>","autoDesc":true}');export{t as data};
