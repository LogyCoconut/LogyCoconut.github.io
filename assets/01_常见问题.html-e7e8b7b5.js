import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,f as e}from"./app-231d45dd.js";const p={},t=e(`<h2 id="线程与进程的关系、区别与缺点" tabindex="-1"><a class="header-anchor" href="#线程与进程的关系、区别与缺点" aria-hidden="true">#</a> 线程与进程的关系、区别与缺点</h2><h3 id="图解进程和线程的关系" tabindex="-1"><a class="header-anchor" href="#图解进程和线程的关系" aria-hidden="true">#</a> 图解进程和线程的关系</h3><p>下图是 Java 内存区域</p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/java/Java 内存区域.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从上图可以看出，一个进程中可以有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器、虚拟机栈、本地方法栈线程是进程划分后的更小运行单位，线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程刚好相反</p><h3 id="为什么程序计数器是私有的" tabindex="-1"><a class="header-anchor" href="#为什么程序计数器是私有的" aria-hidden="true">#</a> 为什么程序计数器是私有的</h3><p>程序计数器的主要作用</p><ul><li><p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理</p></li><li><p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了</p></li></ul><p>需要注意的是，如果执行的 native 方法，那么程序计数器记录的 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条的地址</p><p>所以，程序计数器私有主要<strong>是为了线程切换后能够恢复到正确的执行位置</strong></p><h3 id="虚拟机栈和本地方法栈为什么是私有的" tabindex="-1"><a class="header-anchor" href="#虚拟机栈和本地方法栈为什么是私有的" aria-hidden="true">#</a> 虚拟机栈和本地方法栈为什么是私有的</h3><ul><li><p>虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直到执行完成的过程，就对应着一个栈帧在 Java 虚拟机中入栈、出栈的过程</p></li><li><p>本地方法栈：和虚拟机栈类似，区别是：虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为虚拟机使用的 Native 方法服务</p></li></ul><p>为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的</p><h3 id="堆和方法区" tabindex="-1"><a class="header-anchor" href="#堆和方法区" aria-hidden="true">#</a> 堆和方法区</h3><p>堆和方法区是所有线程共享的资源</p><ul><li><p>堆是进程中最大的一块内存，主要用于存放新创建的对象（所有对象都在这里分配内存）</p></li><li><p>方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p></li></ul><p>(JDK1.7之后 JVM 将运行时常量池从方法区移了出来，在 Java 堆中开辟了一块区域存放运行时常量池)</p><h2 id="线程的生命周期和状态" tabindex="-1"><a class="header-anchor" href="#线程的生命周期和状态" aria-hidden="true">#</a> 线程的生命周期和状态</h2><p>使用多线程可能会导致<strong>内存泄漏、上下文切换频繁、死锁</strong></p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/java/线程的生命周期和状态.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="什么是上下文切换" tabindex="-1"><a class="header-anchor" href="#什么是上下文切换" aria-hidden="true">#</a> 什么是上下文切换？</h2><p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态</p><p><strong>任务从保存到再加载的过程就是一次上下文切换</strong></p><h2 id="什么是线程死锁-如何避免死锁" tabindex="-1"><a class="header-anchor" href="#什么是线程死锁-如何避免死锁" aria-hidden="true">#</a> 什么是线程死锁？如何避免死锁？</h2><p>多个线程同时被阻塞，他们的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止</p><p><strong>产生死锁的四个条件</strong></p><ul><li><p>互斥条件：该资源任意一个时刻只由一个线程占有</p></li><li><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</p></li><li><p>不剥夺条件：线程已获得的资源在未使用完之前不能被其他资源强行剥夺，只有自己使用完毕后才释放资源</p></li><li><p>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</p></li></ul><p><strong>避免线程死锁（一一对应）</strong></p><ol><li><p>互斥条件无法破坏，因为这就是我们用锁的目的</p></li><li><p>一次性申请所有的资源</p></li><li><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占用的资源</p></li><li><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放</p></li></ol><h2 id="synchronized关键字是怎么使用的" tabindex="-1"><a class="header-anchor" href="#synchronized关键字是怎么使用的" aria-hidden="true">#</a> synchronized关键字是怎么使用的</h2><p>最主要的三种使用方式</p><ul><li><p>修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Synchronized</span> <span class="token keyword">void</span> method <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//业务代码</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>修饰静态方法：也就是给当前类给锁，会作用于类的所有对象实例，进入同步代码前要获得当前 class 的锁。因为静态成员不属于任何一个实例对象，是类成员</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>   <span class="token keyword">synchronized</span> staic <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">//业务代码</span>
   <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>修饰代码块：指定加锁对象，对给定对象/类加锁。</p></li><li><p><code>synchronized(this|object)</code>表示进入同步代码块前要获得给定对象的锁</p></li><li><p><code>synchronized(类.class)</code>表示进入同步代码块前要获得给定类的锁</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//业务代码</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="java-内存模型-jmm" tabindex="-1"><a class="header-anchor" href="#java-内存模型-jmm" aria-hidden="true">#</a> Java 内存模型（JMM）</h2><p>当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了变量的值，而另一个线程还在继续使用它的寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong> !</p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/java/Java 内存模型1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>要解决这个问题，就需要把变量声明为 volatile，这就指示 JVM，这个变量是共享而且不稳定的，每次使用它都要到主存中进行读取所以 volatile 除了防止 JVM 的指令重排之外，还可以保证变量的可见性</p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/java/Java 内存模型2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="synchronized和volatile关键字的区别" tabindex="-1"><a class="header-anchor" href="#synchronized和volatile关键字的区别" aria-hidden="true">#</a> synchronized和volatile关键字的区别</h2><ul><li><p>volatile 关键字是线程同步的轻量级实现，所以 volatile 性能肯定比 synchronized 要好。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块</p></li><li><p>volatile 可以保证数据的可见性但是不能保证数据的原子性，synchronized 两者都能保证</p></li><li><p>volatile 主要用于解决变量在多个线程之间的可见性，而 synchronized 解决的是多个线程之间访问资源的同步性</p></li></ul><h2 id="threadlocal-原理" tabindex="-1"><a class="header-anchor" href="#threadlocal-原理" aria-hidden="true">#</a> ThreadLocal 原理</h2><p>主要解决的是让每个线程绑定自己的值</p><p>每个 ThreadLocal 变量相当于一个格子</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
 
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token comment">/* ThreadLocal values pertaining to this thread. This map is maintained
     * by the ThreadLocal class. */</span>
    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> threadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">ThreadLocalMap<span class="token punctuation">.</span>Entry</span> e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
                <span class="token class-name">T</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">return</span> result<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">private</span> <span class="token class-name">T</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">T</span> value <span class="token operator">=</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​<br> Thread 类中有一个 threadLocals，默认为 null</p><p>只有当当前线程调用 ThreadLocal 类的 get 或 set 方法时才创建它（从源码可以看到），最终的变量是放在了当前线程的 threadLocals 中，并不是存在 ThreadLocal 中</p><p>ThreadLocal 可以理解为只是 ThreadLocalMap 的封装，传递了变量值 ThreadLocals 的键就是 ThreadLocal 对象，值就是要存放的 Object 对象</p><h3 id="threadlocal的内存泄漏问题" tabindex="-1"><a class="header-anchor" href="#threadlocal的内存泄漏问题" aria-hidden="true">#</a> ThreadLocal的内存泄漏问题</h3><p>ThreaLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。所以，如果 ThreadLocal 没有被外部强制的情况下，在垃圾回收的时候，key 会被清掉，而 value 不会被清掉</p><p>这样一来，ThreadLocalMap 里面就会出现 key 为 null 的 Entry，这个 value 永远无法被 GC 回收，就会发生内存泄漏。但是 ThreadLocal 已经考虑了这种情况，在调用 set、get、remove 方法时，会清理掉 key 为 null 的数据</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">{</span>
    
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
        <span class="token doc-comment comment">/** The value associated with this ThreadLocal. */</span>
        <span class="token class-name">Object</span> value<span class="token punctuation">;</span>

        <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
            value <span class="token operator">=</span> v<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>  
    
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池" aria-hidden="true">#</a> 线程池</h2><h3 id="为什么使用线程池" tabindex="-1"><a class="header-anchor" href="#为什么使用线程池" aria-hidden="true">#</a> 为什么使用线程池</h3><ul><li><p>降低资源消耗。通过重复利用已创建的线程降低线程的创建和销毁造成的消耗</p></li><li><p>提高响应速度。当任务到达时，不需要创建线程就可以立即执行</p></li><li><p>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</p></li></ul><h3 id="runnable-接口和-callable-接口的区别" tabindex="-1"><a class="header-anchor" href="#runnable-接口和-callable-接口的区别" aria-hidden="true">#</a> Runnable 接口和 Callable 接口的区别</h3><p>Runnable 接口不会返回结果或者抛出检查异常，但是 callable 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 Runable 接口</p><h3 id="执行-execute-和-submit-方法" tabindex="-1"><a class="header-anchor" href="#执行-execute-和-submit-方法" aria-hidden="true">#</a> 执行 execute()和 submit()方法</h3><ul><li><p>execute()用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否</p></li><li><p>submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get 方法获取返回值，get 方法会一直阻塞当前线程直到任务完成，而使用带参 get 方法（get(long timeout, TimeUnit unit)）则只会阻塞一段时间，这时候有可能任务未完成</p></li></ul><h3 id="如何创建线程池" tabindex="-1"><a class="header-anchor" href="#如何创建线程池" aria-hidden="true">#</a> 如何创建线程池</h3><ul><li><p>通过 Executors 创建，可以创建三种类型的 ThreadPoolExecutor</p></li><li><p>FixedThreadPool：一个固定线程数量的线程池。允许请求的队列长度为 Integer.MAX_VALUE</p></li><li><p>SingleThreadExecutor：一个只有一个线程的线程池。允许请求的队列长度为 Integer.MAX_VALUE</p></li><li><p>CachedThreadPool：一个可以根据实际情况调整线程数量的线程池。允许创建的线程数量为 Integer.MAX_VALUE</p></li><li><p>通过 ThreadPoolExecutor 构造方法实现</p></li></ul><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/java/ThreadPoolExecutor构造方法.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们只看最长的构造函数</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                              <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
                              <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
                              <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>
                              <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><strong>corePoolSize</strong>：最小可以同时运行的线程数量</p></li><li><p><strong>maximumPoolSize</strong>：当队列中存放的任务达到队列容量时，当前可以同时运行的线程数变为最大线程数</p></li><li><p><strong>wordQueue</strong>：当新任务来的时候先判断当前运行的线程是否达到核心线程数，如果达到的话，新任务就会被存放在队列中</p></li><li><p>keepAliveTime：当线程池的数量大于核心线程数时，如果这时没有新的任务提交，那么核心线程外的线程会在等待 keepAliveTime 之后销毁</p></li><li><p>unit：时间单位</p></li><li><p>threadFactory：创建新线程的工厂</p></li><li><p>handler：饱和策略</p><ul><li><p><code>ThreadPoolExector.AbortPolicy</code>：抛出 <code>RejectedExecutionException</code> 来拒绝新任务的处理</p></li><li><p><code>ThreadPoolExector.CallerRunsPolicy</code>：调用执行自己的线程运行任务，会降低新任务的提交速度，影响整体性能</p></li><li><p><code>ThreadPoolExector.DiscardPolicy</code>：不处理新任务，直接丢弃掉</p></li><li><p><code>ThreadPoolExector.DiscardOldestPolicy</code>：此策略将丢弃最早的未处理的任务请求</p></li></ul></li></ul><h3 id="线程池原理" tabindex="-1"><a class="header-anchor" href="#线程池原理" aria-hidden="true">#</a> 线程池原理</h3><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/java/线程池原理.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="aqs及其原理" tabindex="-1"><a class="header-anchor" href="#aqs及其原理" aria-hidden="true">#</a> AQS及其原理</h2><p>AQS 是一个构建同步器和锁的框架，使用 AQS 能简单且高效的构造出大量的同步器</p><p><strong>核心思想：</strong></p><ul><li><p>如果被请求的资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态</p></li><li><p>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制是用 CLH 队列的变种实现的，将暂时获取不到锁的线程加入到队列中</p></li></ul><p><em>CLH：Craig、Landin and Hagersten 队列，是单向链表，AQS 中的队列是 CLH 变体的虚拟双向队列（FIFO），AQS 是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配</em></p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/java/AQS示意图.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>`,73),l=[t];function i(c,o){return a(),s("div",null,l)}const r=n(p,[["render",i],["__file","01_常见问题.html.vue"]]);export{r as default};
