import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as t,c as o,a,b as c,d as i,f as s}from"./app-5e910552.js";const h={},d=s('<h3 id="原理图" tabindex="-1"><a class="header-anchor" href="#原理图" aria-hidden="true">#</a> 原理图</h3><h4 id="jdk1-7中的-concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#jdk1-7中的-concurrenthashmap" aria-hidden="true">#</a> JDK1.7中的 ConcurrentHashMap</h4><p>采用了分段锁的思想，将 HashMap 进行分隔，把 HashMap 中的哈希数组切分成小数组，每个小数组有 n 个 HashEntry 组成，其中小数组继承自 <code>ReentrantLock</code>，这个小数组名叫 <code>Segment</code></p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/java/ConcurrentHashMap java7 锁图.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h4 id="jdk1-8中的改动" tabindex="-1"><a class="header-anchor" href="#jdk1-8中的改动" aria-hidden="true">#</a> JDK1.8中的改动</h4><p>JDK1.8对 HashMap 做了改动，<strong>当冲突链表长度超过8时，会将链表转化成红黑树</strong></p><p>1.8后取消了分段锁，采用 CAS + synchronized 来保证并发安全</p><p>synchronized 只锁定当前链表或者红黑树的首节点，只存节点 Hash 不冲突，就不会产生并发</p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/java/ConcurrentHashMap java8 锁图.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接" aria-hidden="true">#</a> 参考链接</h3>',10),p={href:"http://www.justdojava.com/2019/12/18/java-collection-15.1/",target:"_blank",rel:"noopener noreferrer"};function l(g,_){const e=r("ExternalLinkIcon");return t(),o("div",null,[d,a("p",null,[a("a",p,[c("面试必问之 ConcurrentHashMap 线程安全的具体实现方式"),i(e)])])])}const m=n(h,[["render",l],["__file","02_ConcurrentHashMap 实现线程安全.html.vue"]]);export{m as default};
