import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o,c as r,a as e,b as n,d,f as i}from"./app-e0178adb.js";const c={},l=i(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>💡 Dockerfile 是一个用来构建镜像的文本文件, 文本内容包含了一条条构建镜像所需的指令和说明
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="举个🌰" tabindex="-1"><a class="header-anchor" href="#举个🌰" aria-hidden="true">#</a> 举个🌰</h2><h3 id="构建一个-nginx-镜像-并初始化一个-index-文件" tabindex="-1"><a class="header-anchor" href="#构建一个-nginx-镜像-并初始化一个-index-文件" aria-hidden="true">#</a> 构建一个 <code>nginx</code> 镜像，并初始化一个 <code>index</code> 文件</h3><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token comment"># 指定基础镜像为 nginx</span>
<span class="token instruction"><span class="token keyword">FROM</span> nginx</span>

<span class="token comment"># 在上层基础之上在 /usr/share/nginx/html 目录增加一个 index.html 文件</span>
<span class="token instruction"><span class="token keyword">RUN</span> echo <span class="token string">&#39;这是一个本地构建的nginx镜像&#39;</span> &gt; /usr/share/nginx/html/index.html</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="构建一个-java8-镜像" tabindex="-1"><a class="header-anchor" href="#构建一个-java8-镜像" aria-hidden="true">#</a> 构建一个 <code>Java8</code> 镜像</h3><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token comment"># 指定基础镜像为 java8</span>
<span class="token instruction"><span class="token keyword">FROM</span> java:8</span>

<span class="token comment"># 拷贝当前目录到镜像中的 /var/my/java 目录</span>
<span class="token instruction"><span class="token keyword">COPY</span> . /var/my/java  </span>

<span class="token comment"># 设置工作目录为 /var/my/java</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /var/my/java  </span>

<span class="token comment"># 编译 Hello.java 文件</span>
<span class="token instruction"><span class="token keyword">RUN</span> javac Hello.java</span>

<span class="token comment"># 容器启动时运行 java Hello</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;java&quot;</span>, <span class="token string">&quot;Hello&quot;</span>]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="指令作用" tabindex="-1"><a class="header-anchor" href="#指令作用" aria-hidden="true">#</a> 指令作用</h2><table><thead><tr><th>指令名</th><th>说明</th></tr></thead><tbody><tr><td>FROM</td><td>指定基础镜像</td></tr><tr><td>MAINTAINER</td><td>指定维护者信息</td></tr><tr><td>RUN</td><td>想在容器里执行什么命令</td></tr><tr><td>ADD</td><td>给容器一点启动资金</td></tr><tr><td>WORKDIR</td><td>指定当前工作目录，类似 CD</td></tr><tr><td>VOLUME</td><td>设置卷，挂载主机目录</td></tr><tr><td>EXPOSE</td><td>打开</td></tr><tr><td>CMD</td><td>容器启动后要干的事情</td></tr></tbody></table><h3 id="上下文路径" tabindex="-1"><a class="header-anchor" href="#上下文路径" aria-hidden="true">#</a> 上下文路径</h3><p><code>docker build -t nginx:v .</code></p><p>由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</p><p>如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置</p><p>上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢</p><h3 id="from" tabindex="-1"><a class="header-anchor" href="#from" aria-hidden="true">#</a> FROM</h3><p>指定基础镜像，后续的操作都是基于基础镜像（ <code>Dockerfile</code>文件必须以 <code>FROM</code> 作为第一行）</p><h3 id="label" tabindex="-1"><a class="header-anchor" href="#label" aria-hidden="true">#</a> LABEL</h3><p>为镜像添加标签</p><p><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></p><p>例如 <code>LABEL author=&quot;logycoconut&quot; version=0.1</code></p><h3 id="run" tabindex="-1"><a class="header-anchor" href="#run" aria-hidden="true">#</a> RUN</h3><p><code>RUN</code> 指令有两种形式</p><ul><li><code>RUN &lt;command&gt; (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)</code></li><li><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></li></ul><p>每一个 <code>RUN</code> 指令都会构建新的一层</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token comment"># 应该避免下面这种形式，会产生非常多层的镜像，增加构建部署的时间</span>
<span class="token instruction"><span class="token keyword">RUN</span> apk upgrade</span>
<span class="token instruction"><span class="token keyword">RUN</span> apk add python3</span>

<span class="token comment"># 推荐的形式，以 &amp;&amp; 符号连接命令</span>
<span class="token instruction"><span class="token keyword">RUN</span> apk upgrade &amp;&amp; \\<span class="token operator">\\</span></span>
    apk add python3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="cmd" tabindex="-1"><a class="header-anchor" href="#cmd" aria-hidden="true">#</a> CMD</h3><p><code>CMD</code> 命令类似于 <code>RUN</code>，不同点在于运行的时间点</p><ul><li><code>CMD</code> 在docker run 时运行</li><li><code>RUN</code> 是在 docker build 时运行</li></ul><p><code>CMD</code> 命令有三种形式</p><ul><li><p><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> (<em>exec</em> form, this is the preferred form)</p></li><li><p><code>CMD command param1 param2</code> (<em>shell</em> form)</p></li><li><p><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> (作为 <em>ENTRYPOINT 的默认参数</em>)</p></li></ul><h3 id="copy、add" tabindex="-1"><a class="header-anchor" href="#copy、add" aria-hidden="true">#</a> COPY、ADD</h3><p><em>ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）</em></p><p><code>COPY</code> 命令有两种形式</p><ul><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code></li></ul><p><strong>注意：</strong></p><ol><li>source路径必须在构建的上下文之内。不能使用 <code>COPY ../a/b</code>的形式，因为docker构建的第一步是将上下文路径发送到docker引擎</li><li>如果source是目录，则会复制目录的全部内容，包括文件系统元数据</li></ol><p><strong>ADD指令与CPOY指令对比</strong></p><ul><li><p>ADD 的优点：在执行 <code>&lt;src&gt;</code> 为 tar 压缩文件，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 <code>&lt;dest&gt;</code></p></li><li><p>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</p></li></ul><h3 id="env" tabindex="-1"><a class="header-anchor" href="#env" aria-hidden="true">#</a> ENV</h3><p>设置环境变量, <code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token comment"># Dockerfile 设置了 VERSION=0.1</span>
<span class="token instruction"><span class="token keyword">ENV</span> VERSION=0.1</span>

<span class="token comment"># 在镜像启动的容器中 echo</span>
root@caa46eb11ab6:/# echo $VERSION
0.1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="arg" tabindex="-1"><a class="header-anchor" href="#arg" aria-hidden="true">#</a> ARG</h3><p><code>ARG</code> 与<code>ENV</code> 作用一致，作用域不同</p><p>ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>`,44),p={href:"https://docs.docker.com/engine/reference/builder/#environment-replacement",target:"_blank",rel:"noopener noreferrer"},u={href:"https://www.cnblogs.com/edisonchou/p/dockerfile_inside_introduction.html",target:"_blank",rel:"noopener noreferrer"},m={href:"https://www.yiibai.com/docker/docker-dockerfile.html",target:"_blank",rel:"noopener noreferrer"};function h(v,k){const a=t("ExternalLinkIcon");return o(),r("div",null,[l,e("ul",null,[e("li",null,[e("a",p,[n("Docker官方文档"),d(a)])]),e("li",null,[e("a",u,[n("你必须知道的Dockerfile - Edison Zhou"),d(a)])]),e("li",null,[e("a",m,[n("Dockerfile示例与解析 - 易百教程"),d(a)])])])])}const f=s(c,[["render",h],["__file","02_Dockerfile常用指令介绍与示例.html.vue"]]);export{f as default};
