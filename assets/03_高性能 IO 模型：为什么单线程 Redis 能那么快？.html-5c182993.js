const e=JSON.parse('{"key":"v-3d622812","path":"/01_Project/Redis/Redis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%20-%20%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/03_%E9%AB%98%E6%80%A7%E8%83%BD%20IO%20%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B%20Redis%20%E8%83%BD%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%9F.html","title":"03_高性能 IO 模型：为什么单线程 Redis 能那么快？","lang":"zh-CN","frontmatter":{"title":"03_高性能 IO 模型：为什么单线程 Redis 能那么快？","tag":["Redis"],"category":["Redis 核心技术与实战"],"description":"我们通常说，Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但是 Redis 的其他功能，比如说持久化、异步删除、集群数据同步等，其实是由额外的线程执行的 所以严格来说，Redis 并不是单线程，但是我们一般把 Redis 称为单线程高性能 这也促使我们提问：为什么用单线程？为什么单线程能这么快？","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/01_Project/Redis/Redis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%20-%20%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/03_%E9%AB%98%E6%80%A7%E8%83%BD%20IO%20%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B%20Redis%20%E8%83%BD%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%9F.html"}],["meta",{"property":"og:title","content":"03_高性能 IO 模型：为什么单线程 Redis 能那么快？"}],["meta",{"property":"og:description","content":"我们通常说，Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但是 Redis 的其他功能，比如说持久化、异步删除、集群数据同步等，其实是由额外的线程执行的 所以严格来说，Redis 并不是单线程，但是我们一般把 Redis 称为单线程高性能 这也促使我们提问：为什么用单线程？为什么单线程能这么快？"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-29T05:28:50.000Z"}],["meta",{"property":"article:author","content":"logycoconut"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:modified_time","content":"2024-02-29T05:28:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"03_高性能 IO 模型：为什么单线程 Redis 能那么快？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-29T05:28:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://github.com/logycoconut\\"}]}"]]},"headers":[{"level":2,"title":"Redis 为什么使用单线程？","slug":"redis-为什么使用单线程","link":"#redis-为什么使用单线程","children":[{"level":3,"title":"多线程的开销","slug":"多线程的开销","link":"#多线程的开销","children":[]},{"level":3,"title":"线程数与系统吞吐率","slug":"线程数与系统吞吐率","link":"#线程数与系统吞吐率","children":[]},{"level":3,"title":"多线程并发访问 Redis","slug":"多线程并发访问-redis","link":"#多线程并发访问-redis","children":[]}]},{"level":2,"title":"单线程 Redis 为什么这么快","slug":"单线程-redis-为什么这么快","link":"#单线程-redis-为什么这么快","children":[{"level":3,"title":"基本 IO 模型与阻塞点","slug":"基本-io-模型与阻塞点","link":"#基本-io-模型与阻塞点","children":[]},{"level":3,"title":"非阻塞模式","slug":"非阻塞模式","link":"#非阻塞模式","children":[]},{"level":3,"title":"基于多路复用的高性能 IO 模型","slug":"基于多路复用的高性能-io-模型","link":"#基于多路复用的高性能-io-模型","children":[]}]}],"git":{"createdTime":1709184530000,"updatedTime":1709184530000,"contributors":[{"name":"logycoconut","email":"logycoconut@foxmail.com","commits":1}]},"readingTime":{"minutes":7.84,"words":2351},"filePathRelative":"01_Project/Redis/Redis 核心技术与实战 - 极客时间/03_高性能 IO 模型：为什么单线程 Redis 能那么快？.md","localizedDate":"2024年2月29日","excerpt":"<p>我们通常说，<code>Redis</code> 是单线程，主要是指 <code>Redis</code> 的网络 IO 和键值对读写是由一个线程来完成的，这也是 <code>Redis</code> 对外提供键值存储服务的主要流程。但是 <code>Redis</code> 的其他功能，比如说持久化、异步删除、集群数据同步等，其实是由额外的线程执行的</p>\\n<p>所以严格来说，<code>Redis</code> 并不是单线程，但是我们一般把 <code>Redis</code> 称为单线程高性能<br>\\n这也促使我们提问：<strong>为什么用单线程？为什么单线程能这么快？</strong></p>","autoDesc":true}');export{e as data};
