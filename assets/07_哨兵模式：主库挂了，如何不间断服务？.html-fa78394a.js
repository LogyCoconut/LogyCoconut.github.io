const t=JSON.parse('{"key":"v-6606e5b0","path":"/01_Project/Redis/Redis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%20-%20%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/07_%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%B8%BB%E5%BA%93%E6%8C%82%E4%BA%86%EF%BC%8C%E5%A6%82%E4%BD%95%E4%B8%8D%E9%97%B4%E6%96%AD%E6%9C%8D%E5%8A%A1%EF%BC%9F.html","title":"07_哨兵模式：主库挂了，如何不间断服务？","lang":"zh-CN","frontmatter":{"title":"07_哨兵模式：主库挂了，如何不间断服务？","tag":["Redis"],"category":["Redis 核心技术与实战"],"description":"之前我们学习了主从库集群模式 在这个模式下，如果从库发生故障了，客户端就可以继续向主库或其他从库发送请求，进行相关的操作，但是如果主库发生故障了，那就直接会影响到从库的同步，因为从库没有相应的主库可以进行数据复制操作了 而且，如果客户端发送的都是读操作请求，那还可以由从库继续提供服务，这在纯读的业务场景下还能被接收 但是一旦有写操作请求了，按照主从库模式下的读写分离要求，需要由主库来完成写操作 此时，也没有实例可以来服务客户端的写操作请求了","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/01_Project/Redis/Redis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%20-%20%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/07_%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%B8%BB%E5%BA%93%E6%8C%82%E4%BA%86%EF%BC%8C%E5%A6%82%E4%BD%95%E4%B8%8D%E9%97%B4%E6%96%AD%E6%9C%8D%E5%8A%A1%EF%BC%9F.html"}],["meta",{"property":"og:title","content":"07_哨兵模式：主库挂了，如何不间断服务？"}],["meta",{"property":"og:description","content":"之前我们学习了主从库集群模式 在这个模式下，如果从库发生故障了，客户端就可以继续向主库或其他从库发送请求，进行相关的操作，但是如果主库发生故障了，那就直接会影响到从库的同步，因为从库没有相应的主库可以进行数据复制操作了 而且，如果客户端发送的都是读操作请求，那还可以由从库继续提供服务，这在纯读的业务场景下还能被接收 但是一旦有写操作请求了，按照主从库模式下的读写分离要求，需要由主库来完成写操作 此时，也没有实例可以来服务客户端的写操作请求了"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-29T15:10:21.000Z"}],["meta",{"property":"article:author","content":"logycoconut"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:modified_time","content":"2024-02-29T15:10:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"07_哨兵模式：主库挂了，如何不间断服务？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-29T15:10:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://github.com/logycoconut\\"}]}"]]},"headers":[{"level":3,"title":"哨兵机制的基本流程","slug":"哨兵机制的基本流程","link":"#哨兵机制的基本流程","children":[]},{"level":3,"title":"主观下线和客观下线","slug":"主观下线和客观下线","link":"#主观下线和客观下线","children":[]},{"level":3,"title":"如何选定新主库？","slug":"如何选定新主库","link":"#如何选定新主库","children":[]}],"git":{"createdTime":1709184530000,"updatedTime":1709219421000,"contributors":[{"name":"logycoconut","email":"logycoconut@foxmail.com","commits":2}]},"readingTime":{"minutes":9.31,"words":2792},"filePathRelative":"01_Project/Redis/Redis 核心技术与实战 - 极客时间/07_哨兵模式：主库挂了，如何不间断服务？.md","localizedDate":"2024年2月29日","excerpt":"<p>之前我们学习了主从库集群模式<br>\\n在这个模式下，如果从库发生故障了，客户端就可以继续向主库或其他从库发送请求，进行相关的操作，但是如果主库发生故障了，那就直接会影响到从库的同步，因为从库没有相应的主库可以进行数据复制操作了</p>\\n<p>而且，如果客户端发送的都是读操作请求，那还可以由从库继续提供服务，这在纯读的业务场景下还能被接收<br>\\n但是一旦有写操作请求了，按照主从库模式下的读写分离要求，需要由主库来完成写操作<br>\\n此时，也没有实例可以来服务客户端的写操作请求了<br>\\n<img src=\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240229181449.png\\" alt=\\"主库故障后从库无法服务写操作\\" loading=\\"lazy\\"></p>","autoDesc":true}');export{t as data};
