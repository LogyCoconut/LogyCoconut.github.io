import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as s,o as t,c as o,a,b as p,d as c,f as r}from"./app-231d45dd.js";const i={},l={href:"https://www.bilibili.com/video/BV1Zy411e7qY/?share_source=copy_web&vd_source=d3cf8d37233f4f5206017ef71b7071e8",target:"_blank",rel:"noopener noreferrer"},d=r(`<h1 id="kafka-为什么这么快-rocketmq-哪里不如-kafka" tabindex="-1"><a class="header-anchor" href="#kafka-为什么这么快-rocketmq-哪里不如-kafka" aria-hidden="true">#</a> Kafka 为什么这么快？RocketMQ 哪里不如 Kafka？</h1><p>RocketMQ 在设计上参考了 Kafka，架构上更简单，功能更加丰富<br> 看起来似乎是 RocketMQ 更加能打</p><p>但是 Kafka 一直没有被淘汰，说明 RocketMQ 必然有着不如 Kafka 的地方<br> 是什么呢？</p><p><strong>性能！严格来说是吞吐量</strong><br> 数据显示，RocketMQ 每秒能处理 10W 量级的数据，而 Kafka 则是 17W<br><em>快则快矣，但其实也并没有拉开量级的性能差距</em></p><h3 id="消息从消息队列的磁盘发送到消费者-过程是怎么样的" tabindex="-1"><a class="header-anchor" href="#消息从消息队列的磁盘发送到消费者-过程是怎么样的" aria-hidden="true">#</a> 消息从消息队列的磁盘发送到消费者，过程是怎么样的？</h3><p>消息队列的进程为了防止进程崩溃后丢失消息，一般不会放在内存里，而是放在磁盘上</p><p>操作系统分为用户空间和内核空间<br> 程序处于用户空间，硬盘则属于硬件<br> 操作系统本质上就是程序和硬件之间的中间层，程序需要通过操作系统去调用硬件能力</p><p>如果用户想要将数据从磁盘（消息实际存储的地方）发送到网络（消费者），一般来说会经过这么几个步骤</p><ul><li>程序发起 read () 请求，消息从磁盘拷贝到内核空间中的内核缓冲区</li><li>消息从内核缓冲区拷贝到用户空间的用户缓冲区</li><li>程序发起系统调用 write () 请求，消息从用户缓冲区拷贝到内核空间的 socket 缓冲区</li><li>最后，消息从 socket 缓冲区拷贝到网卡上，发送到网络中，最终到达消费者<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240809145531.png" alt="" loading="lazy"></li></ul><p><strong>整个过程总共有 2 次系统调用、4 次用户空间和内核空间的切换、4 次数据拷贝</strong><br> 同样一份数据来回拷贝，效率低下</p><h3 id="零拷贝技术" tabindex="-1"><a class="header-anchor" href="#零拷贝技术" aria-hidden="true">#</a> 零拷贝技术</h3><p>常见的方案有两种，分别是 mmap 和 sendfile</p><h4 id="mmap" tabindex="-1"><a class="header-anchor" href="#mmap" aria-hidden="true">#</a> mmap</h4><p>mmap 是操作系统提供的一个方法，可以将内核空间的缓冲区映射到用户空间</p><p>使用它后，上文提到的发送流程就会产生变化</p><ul><li>程序发起 mmap () 请求，消息从磁盘拷贝到内核空间中的内核缓冲区</li><li>消息从内核缓冲区<strong>映射</strong>到用户空间的用户缓冲区（这里不需要拷贝）</li><li>程序发起系统调用 write () 请求，消息从内核缓冲区拷贝到内核空间的 socket 缓冲区</li><li>最后，消息从 socket 缓冲区拷贝到网卡上，发送到网络中，最终到达消费者<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240809150526.png" alt="" loading="lazy"></li></ul><p><strong>整个过程总共有 2 次系统调用、4 次用户空间和内核空间的切换、3 次数据拷贝</strong><br><strong>省下了 1 次数据拷贝</strong></p><p><em>相信大家也发现了，零拷贝技术并不意味着 1 次拷贝都没有，它只是说在用户空间到内核空间这个过程不需要拷贝</em></p><h4 id="sendfile" tabindex="-1"><a class="header-anchor" href="#sendfile" aria-hidden="true">#</a> sendfile</h4><p>顾名思义，sendfile 就是用来发送文件数据的</p><ul><li>程序发起 sendfile () 请求，消息从磁盘拷贝到内核空间中的内核缓冲区</li><li>消息从内核缓冲区通过 SG-DMA 直接拷贝到网卡<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240809151001.png" alt="" loading="lazy"></li></ul><p><strong>整个过程总共有 1 次系统调用、2 次用户空间和内核空间的切换、2 次数据拷贝</strong></p><p><em>这里的零拷贝指的是 0 CPU 拷贝，sendfile 参与的场景下都不是 CPU 直接参与的拷贝，而是 DMA 控制器在干活，不耽误 CPU 跑程序</em></p><h3 id="所以说-kafka-的性能为什么比-rocketmq-好" tabindex="-1"><a class="header-anchor" href="#所以说-kafka-的性能为什么比-rocketmq-好" aria-hidden="true">#</a> 所以说，Kafka 的性能为什么比 RocketMQ 好？</h3><p>这是因为 RocketMQ 使用的是 mmap 技术，而 Kafka 则选择了 sendfile<br> Kafka 以更少的拷贝次数以及系统内核切换次数获得了更好的性能</p><p>那么问题来了，RocketMQ 为什么不使用 sendfile 技术呢？<br> 难道是阿里的程序员连抄作业都不会？</p><p>这里我们需要看一下这两个函数的具体用法</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">sendfile</span><span class="token punctuation">(</span><span class="token keyword">int</span> out_fd<span class="token punctuation">,</span> j _fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span><span class="token operator">*</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// num = sendfile(xxxx);</span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> prot<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// buf = mmap(xxxx);</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>仔细分析就能发现<br> mmap 返回的是数据的具体内容，应用层能获取到消息内容并进行逻辑处理<br> 而 sendfile 则是成功发送了几个字节数，具体发送什么则是什么都不知道</p><p>RocketMQ 的某些功能特性，则需要获取到消息的具体内容，比如说将消费失败的消息重新投递到死信队列中<br> 而 Kafka 为了极致的性能，则选择放弃了这些特性</p><p><strong>没有一种架构是完美的，一种架构往往用于适配某些场景，很难做到既要又要</strong><br><strong>做架构，做到最后都是在做折中</strong></p>`,31);function k(f,u){const n=s("ExternalLinkIcon");return t(),o("div",null,[a("blockquote",null,[a("p",null,[a("a",l,[p("Kafka 为什么这么快？RocketMQ 哪里不如 Kafka？ - 小白 debug"),c(n)])])]),d])}const _=e(i,[["render",k],["__file","Kafka 为什么这么快？RocketMQ 哪里不如 Kafka？.html.vue"]]);export{_ as default};
