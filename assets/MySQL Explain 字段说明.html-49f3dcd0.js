import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as i,f as n}from"./app-d4eb8940.js";const r={},d=n('<h2 id="explain-字段中-type-字段效率对比" tabindex="-1"><a class="header-anchor" href="#explain-字段中-type-字段效率对比" aria-hidden="true">#</a> explain 字段中 type 字段效率对比</h2><figure><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/76f3bb8f-140f-4187-a751-adf54f18e60a/Untitled.png" alt="Untitled" tabindex="0" loading="lazy"><figcaption>Untitled</figcaption></figure><h3 id="const" tabindex="-1"><a class="header-anchor" href="#const" aria-hidden="true">#</a> const</h3><p>主键或UNIQUE唯一索引，最多只会返回一条</p><h3 id="system" tabindex="-1"><a class="header-anchor" href="#system" aria-hidden="true">#</a> system</h3><figure><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/55ad62be-9678-4fec-9412-ca413bf53e65/Untitled.png" alt="Untitled" tabindex="0" loading="lazy"><figcaption>Untitled</figcaption></figure><p>在 const 的基础上，如果表里只有一条数据，那就是system</p><p>属于 const 的一种特殊情况</p><p>不会出现在 innoDB 中，在 MyISAM 中会出现</p><h3 id="eq-ref" tabindex="-1"><a class="header-anchor" href="#eq-ref" aria-hidden="true">#</a> eq_ref</h3><p>通常发生在联表查询中，关联的条件为某一张表的主键或UNIQUE唯一非空索引</p><p>效率仅次于 system 和 const</p><h3 id="ref" tabindex="-1"><a class="header-anchor" href="#ref" aria-hidden="true">#</a> ref</h3><p>满足索引的最左原则，同事并不走主键或者 UNIQUE</p><p>对于非聚簇索引，通常为 ref</p><h3 id="ref-or-null" tabindex="-1"><a class="header-anchor" href="#ref-or-null" aria-hidden="true">#</a> ref_or_null</h3><p>在ref 的基础上增加 null 值的查询</p><p>由于查询 null 值需要扫描整个索引数中的行信息</p><h3 id="index-merge" tabindex="-1"><a class="header-anchor" href="#index-merge" aria-hidden="true">#</a> index_merge</h3><p>对于多个索引分别进行条件扫描，然后对结果进行 并集、交集、或两者的组合</p><h3 id="unique-subquery-和-index-subquery" tabindex="-1"><a class="header-anchor" href="#unique-subquery-和-index-subquery" aria-hidden="true">#</a> unique_subquery 和 index_subquery</h3><p>在 MySQL 的Service服务层会对 SQL 进行优化，所以在存储引擎层不会在出现了</p><p>在这之后的 type 尽量不要出现，效率不高</p><h3 id="range" tabindex="-1"><a class="header-anchor" href="#range" aria-hidden="true">#</a> range</h3><p>范围查询</p><h3 id="index-和-all" tabindex="-1"><a class="header-anchor" href="#index-和-all" aria-hidden="true">#</a> index 和 all</h3><p>都是全表扫描，区别在于index值需要查询索引数就能拿到结果 all 还需要遍历所有行</p><h2 id="explain-字段中-extra" tabindex="-1"><a class="header-anchor" href="#explain-字段中-extra" aria-hidden="true">#</a> explain 字段中 Extra</h2><p>介绍几种常用的</p><figure><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d4a9f1a2-d385-4566-b807-f526ff48fc87/Untitled.png" alt="Untitled" tabindex="0" loading="lazy"><figcaption>Untitled</figcaption></figure><h3 id="using-index" tabindex="-1"><a class="header-anchor" href="#using-index" aria-hidden="true">#</a> using index</h3><p>想查找的数据都在索引树中，不需要回表再去查询聚簇索引</p><p>这样就可以减少不必要的查询，从而提升查询效率</p><h3 id="using-index-condition" tabindex="-1"><a class="header-anchor" href="#using-index-condition" aria-hidden="true">#</a> using index condition</h3><p>索引下推 ICP Index Condition Pushdown</p><p>主要用在联合索引中</p><p>如果搜索时需要大量回表，在回表之前，会先把处理过滤逻辑 “下推” 到存储引擎中进行，过滤整理后才发到 Server 层进行处理</p><p>减少了发给 Server 层的数据量和次数，提升效率</p><h3 id="using-where" tabindex="-1"><a class="header-anchor" href="#using-where" aria-hidden="true">#</a> using where</h3><p>和 ICP 相对 所有过滤动作都由 Server 层处理，效率比较低</p><p>查询的列没有被索引覆盖</p><h3 id="using-mrr" tabindex="-1"><a class="header-anchor" href="#using-mrr" aria-hidden="true">#</a> using MRR</h3><p>Multi-Range Read</p><p>对二级索引查询时，会先对二级索引的查询结果缓存并进行排序，然后统一去聚簇索引中回表查询</p><p>这样就可以把随机IO优化成顺序IO，提升效率</p><p>默认关闭，需要手动开启 mrr_cost_based</p><h3 id="using-join-buffer-block-nested-loop-bnl" tabindex="-1"><a class="header-anchor" href="#using-join-buffer-block-nested-loop-bnl" aria-hidden="true">#</a> using join buffer(Block Nested Loop BNL)</h3><p>主要发生在A B两表关联查询，A的关联列上有索引而B的没有，就会发生BNL优化</p><p>步骤：</p><ol><li>从A表中取10条数据放在 Join Buffer 内存空间中</li><li>全表扫描B表和Join Buffer中这10行关联</li><li>循环这一步，直到A表所有数据关联完</li></ol><p>虽说减少了B表的扫描次数，但还是很慢</p><h3 id="using-join-buffer-batched-key-access-bka" tabindex="-1"><a class="header-anchor" href="#using-join-buffer-batched-key-access-bka" aria-hidden="true">#</a> using join buffer(Batched Key Access BKA)</h3><p>在 BNL 的基础上，如果B表有索引，则会配合 MRR 将JoinBuffer 中的行进行排序后去B表对应索引中查，无需全表扫描</p><p>默认关闭</p><h3 id="using-union-indexs" tabindex="-1"><a class="header-anchor" href="#using-union-indexs" aria-hidden="true">#</a> using union（indexs）</h3><p>多个查询条件都是索引，就会对索引进行合并</p><h3 id="using-temporary" tabindex="-1"><a class="header-anchor" href="#using-temporary" aria-hidden="true">#</a> using temporary</h3><p>查询过程中用到了临时表</p><p>比如 group by、dinstinct、union</p><h3 id="using-filesort" tabindex="-1"><a class="header-anchor" href="#using-filesort" aria-hidden="true">#</a> using filesort</h3><p>通常出现在order by 中</p><p>可以通过优化避免</p><p>比如条件和排序两个字端组成联合索引，定位到条件后，排序字端本身就是有序的，就不需要额外排序了</p>',63),t=[d];function s(h,o){return a(),i("div",null,t)}const u=e(r,[["render",s],["__file","MySQL Explain 字段说明.html.vue"]]);export{u as default};
