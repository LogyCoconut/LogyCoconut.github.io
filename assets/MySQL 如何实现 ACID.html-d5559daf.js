import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c,e as d}from"./app-33ef3045.js";const i={},t=d('<blockquote><p>针对 <code>InnoDB</code> 引擎</p></blockquote><p><code>ACID</code>（<code>Atomicity</code>，<code>Consistency</code>，<code>Isolation</code>， <code>Durability</code> ） 是关系型数据库的重要特性<br><code>MySQL</code> 也通过各种手段来实现了 <code>ACID</code></p><h3 id="isolation-隔离性" tabindex="-1"><a class="header-anchor" href="#isolation-隔离性" aria-hidden="true">#</a> Isolation 隔离性</h3><blockquote><p>解释：并发访问数据库时，一个事务不被其他事务干扰</p></blockquote><p>数据库中存在不同的隔离级别，不同的隔离级别也分别解决了脏读、不可重复读、幻读等问题</p><ul><li>读未提交</li><li>读提交 <code>RC</code></li><li>可重复读 <code>RR</code>（<code>InnoDB</code> 默认隔离级别）</li><li>串行化</li></ul><p><strong>读请求的隔离</strong></p><p>在 <code>RC</code>、<code>RR</code> 隔离级别下，<code>InnoDB</code> 引擎通过 <code>MVCC</code> 来实现事务间数据的</p><p><strong>写请求的隔离</strong></p><h3 id="atomicity-原子性" tabindex="-1"><a class="header-anchor" href="#atomicity-原子性" aria-hidden="true">#</a> Atomicity 原子性</h3><h3 id="durability-持久性" tabindex="-1"><a class="header-anchor" href="#durability-持久性" aria-hidden="true">#</a> Durability 持久性</h3><p>主要是靠 <code>redo log</code></p><p><code>redo log</code> 有两个特点</p><ul><li>大小固定，循环写</li><li>crash-safe</li></ul><p><code>MySQL</code> 中有一个 <code>WAL</code>（<code>Write-Ahead Logging</code>） 技术</p><p>当有记录更新时，InnoDB 引擎就会把记录写到 redo log 中并更新内存，这个时候更新已经完成</p><h3 id="consistency-一致性" tabindex="-1"><a class="header-anchor" href="#consistency-一致性" aria-hidden="true">#</a> Consistency 一致性</h3>',17),a=[t];function n(r,l){return e(),c("div",null,a)}const p=o(i,[["render",n],["__file","MySQL 如何实现 ACID.html.vue"]]);export{p as default};
