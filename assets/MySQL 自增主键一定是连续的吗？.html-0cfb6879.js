import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as l,f as r}from"./app-d43a649e.js";const d={},o=r('<h1 id="mysql-自增主键一定是连续的吗" tabindex="-1"><a class="header-anchor" href="#mysql-自增主键一定是连续的吗" aria-hidden="true">#</a> MySQL 自增主键一定是连续的吗？</h1><blockquote><p>自增主键的特点就是<br> 当表中新增一条记录时，主键值会根据自增步长自动叠加，通常会将自增步长设置为 1，也就是说自增主键值是连续的</p></blockquote><h3 id="自增值存储机制" tabindex="-1"><a class="header-anchor" href="#自增值存储机制" aria-hidden="true">#</a> 自增值存储机制</h3><ul><li>在 MySQL 5.7 以及之前的版本，自增值保存在内存里<br> 每次重启后，第一次打开表的时候，都会去找自增值的最大值 <code>max (id)</code>，然后将 <code>max (id) + 1</code> 作为这个表当前的自增值</li><li>在 MySQL 8.0 版本，将自增值的变更记录在了 <code>redo log</code> 中，重启的时候依靠 <code>redo log</code> 恢复重启之前的值</li></ul><h3 id="导致自增值不连续的原因" tabindex="-1"><a class="header-anchor" href="#导致自增值不连续的原因" aria-hidden="true">#</a> 导致自增值不连续的原因</h3><p>当前， Table A 的 Col B 存在唯一键约束，并且已经存了一条 B=3 的记录了</p><ul><li>唯一键冲突<br> 此时我们继续插入 B=3 的记录，就会出现唯一键冲突插入报错</li></ul><p>但是插入报错并不会将自增值改回去，此时的自增值已经 +1 了，下次插入新值时，对应的 ID 也是自增后的自增值</p><p><em>自增字段值的生成是由存储引擎生成的，而不是优化器完成的，因此，在执行 SQL 语句时，即使未指定自增字段列，也不会对性能产生任何影响</em></p><ul><li><p>事务回滚<br> 很好理解<br> 开启一个事务，并插入 B=4 的记录（此时 id 应该为 4），然后进行回滚<br> 回滚后重新插入 B=4 的记录，此时 ID 为 5</p></li><li><p>批量插入数据</p></li></ul><p>MySQL 在批量插入数据时，会去批量申请 id</p><p>而批量申请 id 的一个策略便是<br><strong>在同一条语句中</strong></p><ul><li>第一次申请，会分配 1 个</li><li>第二次申请，会分配 2 个</li><li>第三次申请，会分配 4 个</li><li>第 n 次申请，会申请 2 的 n-1 次方个</li></ul><p>比如现在有一张新表 Table A，批量插入 5 条数据<br> 那么，在申请 id 时，MySQL 会先申请 1 个，不够，再申请 2 个，还是不够，再申请 4 个，终于够了<br> 5 条新数据，但是自增 id 用了 7 个</p><p>所以，在下一次插入新数据时，自增 id 是从 8 开始的</p>',15),a=[o];function c(t,_){return i(),l("div",null,a)}const s=e(d,[["render",c],["__file","MySQL 自增主键一定是连续的吗？.html.vue"]]);export{s as default};
