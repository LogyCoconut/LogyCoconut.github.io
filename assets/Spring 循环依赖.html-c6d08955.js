import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as l,c as n,a as e,b as i,d as t,f as d}from"./app-0845c340.js";const r={},p={href:"https://www.bilibili.com/video/BV1ET4y1N7Sp",target:"_blank",rel:"noopener noreferrer"},g=e("p",null,[i("大叔讲的非常清楚 !！"),e("br"),i(" 听不懂的建议反复观看")],-1),s=d('<h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h3><ul><li><p>在哪里获取 <code>Bean</code>？<code>Bean</code> 工厂 （<code>ObjectFactory</code>）</p></li><li><p><code>Bean</code> 工厂的 <code>Bean</code> 哪里来？从 <code>Bean</code> 仓库（单例池 <code>SingletonBeanRegistry</code>）中获取</p></li></ul><h3 id="一个简单-bean-的创建和管理" tabindex="-1"><a class="header-anchor" href="#一个简单-bean-的创建和管理" aria-hidden="true">#</a> 一个简单 Bean 的创建和管理</h3><ul><li>获取 Bean，查看单例池中是否存在 A</li><li>单例池中存在，直接返回 A，不存在则实例化一个 A</li><li>为 A 对象填充属性（在例子中为 id 属性）</li><li>完成初始化，并放入单例池中</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231219183133.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="稍复杂-bean-的创建" tabindex="-1"><a class="header-anchor" href="#稍复杂-bean-的创建" aria-hidden="true">#</a> 稍复杂 Bean 的创建</h3><ul><li>获取 Bean，查看单例池中是否存在 A</li><li>单例池中存在，直接返回 A，不存在则实例化一个 A</li><li>为 A 对象填充属性（在例子中为 id 属性）</li><li>A 中有 B 对象，查看单例池中是否存在 B</li><li>存在则直接返回 B，不存在则实例化一个 B</li><li>为 B 对象填充属性（在例子中为 name 属性）</li><li>完成 B 的初始化，并放入单例池中</li><li>完成 A 的初始化，并放入单例池中</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231219183201.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="循环依赖" tabindex="-1"><a class="header-anchor" href="#循环依赖" aria-hidden="true">#</a> 循环依赖</h3><blockquote><p>先前两个例子只需要一个单例池就可以完成 Bean 的创建与管理，下面来看一个稍微复杂的例子</p></blockquote><p><code>Object A</code> 与 <code>Object B</code> 存在相互引用的情况<br> 如果还是按照上述步骤执行的话，那将会陷入无限实例化 <code>Object</code> 的循环中（因为单例池中始终没有所需要的 <code>Bean</code>）</p><p><em><strong>此时，我们增加一个半成品池子（二级缓存）</strong></em></p><ul><li>获取 Bean，查看单例池中是否存在 A</li><li>单例池中存在，直接返回 A，不存在则实例化一个 A，将 A 放入半成品池子中</li><li>为 A 对象填充属性（在例子中为 id 属性）</li><li>A 中有 B 对象，查看单例池中是否存在 B</li><li>存在则直接返回 B，不存在则实例化一个 B，将 B 放入半成品池子中</li><li>为 B 对象填充属性（在例子中为 name 属性）</li><li>为 B 对象填充属性 A，B 先在单例池中查找 A，ok 没有找到，继续在半成品池子中查找 A，此时可以查找到，完成填充</li><li>完成 B 的初始化，并放入单例池中，并移除半成品池中的 B</li><li>完成 A 的初始化，并放入单例池中，并移除半成品池中的 A</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231219183255.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="aop-对象处理" tabindex="-1"><a class="header-anchor" href="#aop-对象处理" aria-hidden="true">#</a> AOP 对象处理</h3><blockquote><p>按照上述的理论，我们已经成功地解决了 <code>Bean</code> 的循环依赖<br> 但是为什么 <code>Spring</code> 中使用了三级缓存来解决循环依赖呢</p><p>对咯，还存在着 <code>AOP</code> 代理的情况～</p></blockquote><p>在存在代理的情况下，<code>Object A </code> 中的属性 b 不应该真的是 <code>Object B</code>，而应该是 <code>Proxy B</code></p><p>而二级缓存解决不了这个问题，所以引入了三级缓存</p><ul><li>*AOP 代理发生在 Bean 的初始化中，在 Bean 的后置处理中生成一个代理对象<br> （ BeanPostProcessor 的 postProcessAfterInitialization，调用 createProxy ）</li><li><em>AOP 处理器中还存在着方法 getEarlyBeanReference，在提前用到 A 对象时调用方法获取代理对象（不提前引用的情况下不会调用）</em></li></ul><p><strong>存在 AOP 代理的情况下，单例池中存放的是代理对象，而不是 Bean 本身!!!</strong></p><p><strong>具体步骤</strong></p><ul><li>获取 Bean，查看单例池中是否存在 A</li><li>单例池中存在，直接返回 A，不存在则实例化一个 A，并创建一个 <code>Factory A</code> 放入工厂池中（<code>Factory A</code> 的作用就是用来调用 <code>getEarlyBeanReference</code> 方法获取代理对象）</li><li>为 A 对象填充属性（在例子中为 id 属性）</li><li>A 中有 B 对象，查看单例池中是否存在 B</li><li>存在则直接返回 B，不存在则实例化一个 B，并创建一个 <code>Factory B</code> 放入工厂池中</li><li>为 B 对象填充属性（在例子中为 name 属性）</li><li>为 B 对象填充属性 A，B 先在单例池中查找 A，ok 没有找到，继续在半成品池子中查找 A，也没有，最终在工厂池中发现了 <code>Factory A</code></li><li>此时满足了 <code>Proxy A</code> 提前引用的条件，调用 <code>getEarlyBeanReference</code> 方法获取代理对象 <code>Proxy A</code> 并放入半成品池子中，并且移除工厂池中的 <code>Factory A</code></li><li>完成 B 的初始化，并放入单例池中，并移除工厂池中的 <code>Factory B</code></li><li>完成 A 的初始化，并放入单例池中，并移除半成品池中的 <code>Proxy A</code></li></ul><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231219183319.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure>',23);function B(h,A){const o=a("ExternalLinkIcon");return l(),n("div",null,[e("blockquote",null,[e("p",null,[i("【第二次讲 Spring 循环依赖，时长 16 分钟，我保证每一秒都是精华】 "),e("a",p,[i("https://www.bilibili.com/video/BV1ET4y1N7Sp"),t(o)])]),g]),s])}const b=c(r,[["render",B],["__file","Spring 循环依赖.html.vue"]]);export{b as default};
