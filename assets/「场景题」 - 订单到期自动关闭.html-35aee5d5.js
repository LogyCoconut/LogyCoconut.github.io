import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as r,f as i}from"./app-f41112f2.js";const d={},l=i(`<h1 id="如何实现订单到期自动关闭" tabindex="-1"><a class="header-anchor" href="#如何实现订单到期自动关闭" aria-hidden="true">#</a> 如何实现订单到期自动关闭？</h1><h3 id="定时任务" tabindex="-1"><a class="header-anchor" href="#定时任务" aria-hidden="true">#</a> 定时任务</h3><p><strong>定期检查数据库中的订单记录</strong><br> 对于已经创建但未在设定时间内完成支付的订单，系统自动将其状态更新为「已关闭」</p><p>可以使用 <code>elastic-job</code>、<code>xxl-job</code> 等框架</p><p>定时任务这种方式简单有效，但是存在几个问题</p><ul><li>时间精确性<br> 定时任务一般基于固定的时间频率来执行的<br> 那么，就会存在订单已经过期，但还没扫描到，那就导致订单比预期时间晚关闭，存在精度问题<br> 如果定时任务设置的过于频繁，那它可能又会对服务器产生不小的影响</li><li>海量订单处理困难<br> 定时任务不仅精度差，而且一次可能会筛选出来许多符合的数据<br> 数据量一大，处理时间就会变长，导致任务超时</li><li>数据库压力大<br> 短时间内需要处理大量的订单状态更新，可能会导致数据库高负荷甚至暂时的服务拥堵</li></ul><h3 id="rocketmq-延迟消息" tabindex="-1"><a class="header-anchor" href="#rocketmq-延迟消息" aria-hidden="true">#</a> RocketMQ 延迟消息</h3><p>RocketMQ 天然支持延迟消息，如订单支付超时、发送定时通知等<br> 在 RocketMQ 中, 可以很容易地实现消息的延迟投递</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>RocketMQ 并没有直接存储原始的延迟时间，而是提供了几个预定义的延迟级别，每个级别对应一个具体的时间长度
当你发送一个延迟消息时，你需要指定这个消息的延迟级别
消息被存储在 Broker 上后，并不会立即投递，而是等待特定的时间后才被投递到目标队列
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如，用户创建完订单后，希望在 15 分钟内，如果没有完成支付，就取消订单<br> 那我们在用户创建完订单后，发个延迟 15 分钟的消息，那 15 分钟后，这个消息就会被消费者消费</p><p>但是，RocketMQ 4.x 版本并不支持任意的延迟时间，它只支持 18 个延迟级别，从 1s 到 2h</p><h3 id="delayqueue-java" tabindex="-1"><a class="header-anchor" href="#delayqueue-java" aria-hidden="true">#</a> DelayQueue（Java）</h3><p>DelayQueue 是一个无界阻塞队列，用于放置实现了 Delayed 接口的对象，其中的元素只能在其到期时才能从队列中取出</p><p>这种方案可以做到精确的时间控制，而且线性安全（毕竟都在一个 Java 进程中）<br> 但是 DelayQueue 是无界的，使用不当可能导致内存溢出<br> 而且不适合分布式系统中的应用，重启的时候，排队的任务可能会丢失</p><h3 id="zset-redis" tabindex="-1"><a class="header-anchor" href="#zset-redis" aria-hidden="true">#</a> ZSet（Redis）</h3><blockquote><p>Redis 的有序集合也可以实现订单到期，自动关闭</p></blockquote><ul><li>订单到期时间作为分数（score）<br> 将订单的到期时间戳作为 ZSet 中每个订单的分数，这样就可以通过分数范围查询到期订单</li><li>订单 ID 作为成员（member）</li><li>定期检查过期订单<br> 例如，每分钟执行一个检查任务，查询 ZSet 中分数小于当前时间戳的订单 ID（即已过期的订单）</li><li>关闭过期订单<br> 对于过期订单，执行关闭订单的操作</li></ul><p>这种方式提供高效的查询和操作，Redis 的 ZSet 提供了高效的有序集合数据结构，能够快速执行插入、删除、范围查询等操作，使得对订单到期时间的管理更加高效<br> 借助 Redis 的持久化、高可用机制，也可以避免数据丢失</p><h3 id="hashedwheeltimer-netty" tabindex="-1"><a class="header-anchor" href="#hashedwheeltimer-netty" aria-hidden="true">#</a> HashedWheelTimer（Netty）</h3><p>Netty 中的 HashedWheelTimer 是一种基于时间轮算法的定时器，常用于处理定时任务和延时任务</p><ul><li>创建 HashedWheelTimer 实例，用于执行定时任务</li><li>添加到期任务<br> 当用户下单时，计算订单的过期时间，并将过期任务添加到 HashedWheelTimer 中</li><li>处理到期任务<br> 当到期时间到达时，HashedWheelTimer 会执行相应的任务，这时就可以在任务中执行关闭订单的操作了</li></ul><p>这种方式也较为简单，适合单机场景，但是需要引入额外的组件</p>`,22),t=[l];function s(h,c){return a(),r("div",null,t)}const u=e(d,[["render",s],["__file","「场景题」 - 订单到期自动关闭.html.vue"]]);export{u as default};
