import{_}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as t,f as r}from"./app-0505bdf9.js";const p={},o=r('<h1 id="「系统设计-」-聊天室已读-未读功能" tabindex="-1"><a class="header-anchor" href="#「系统设计-」-聊天室已读-未读功能" aria-hidden="true">#</a> 「系统设计 」 - 聊天室已读/未读功能</h1><p>聊天室大体上可以分为两种</p><ol><li><strong>类似于微信、QQ 这种聊天为主功能的工具</strong></li></ol><p>用户在使用这类聊天工具时，对于聊天内容的需求主要是两点</p><ul><li>跳到最远未读消息</li><li>回到最新消息</li></ul><p>在聊天室中，每条消息都有自己的 ID，并且这些 ID 是顺序递增的<br> 我们只需要为用户记住在聊天室的最后一条消息的最新 ID，并且在关闭聊天窗口时记住当前的最新 ID，就能实现上述需求</p><p>当消息 ID 大于当时记录的最新 ID 时，这些消息都是未读的，否则就是已读的</p><p>并且在聊天室外显示气泡时，也可以根据最新消息 ID 以及当时最新消息 ID 计算得出错过的消息数量</p><ol start="2"><li><strong>类似于钉钉、飞书这些企业管理工具，聊天只是其中一项功能</strong></li></ol><p>对于聊天气泡这种需求方案与上述类似<br> 但在企业管理工具中，还有一项功能，<em>发言人需要知道谁对发送的消息已读了</em></p><p>那这种数据结构我们该如何进行存储呢？<br> 这里推荐一种方式，Redis 的 bitmap（位图）</p><p>每一条消息，都维护一个 bitmap，群里的每一个人都对应 1位<br> 假设群里有 20 人，那发送人发出的消息就对应着有 20 位（可以多留几位，后续可能还会进人）</p><p>接收人在读取消息后，发送一个请求表明已读，服务端接受请求，并将这条消息的接收人对应位标志为 1<br><em>接收人对应哪一位可以根据入群时间进行排序</em></p><p>那么，发送人在查看这条消息的已读/未读消息时，就可以根据这个 bitmap 来进行计算，判断出群里哪些人已读，哪些人未读</p>',14),i=[o];function l(a,s){return e(),t("div",null,i)}const m=_(p,[["render",l],["__file","「系统设计」 - 聊天室已读未读功能.html.vue"]]);export{m as default};
