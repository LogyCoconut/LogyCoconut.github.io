import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as r,c as a,f as t}from"./app-c91d02ba.js";const p={},h=t('<h2 id="写在前面" tabindex="-1"><a class="header-anchor" href="#写在前面" aria-hidden="true">#</a> 写在前面</h2><p>HTTP（Hyper Text Transfer Protocol ） 是协议</p><p>RPC （Remote Procedure Call）是一种规范</p><p><strong>两者并不能放在一起比较</strong></p><p>HTTP、TCP、UDP 或者厂家自家定的协议都能实现 RPC</p><p>一次 HTTP 请求实际上就是一次 RPC 调用</p><h2 id="tcp-演变" tabindex="-1"><a class="header-anchor" href="#tcp-演变" aria-hidden="true">#</a> TCP 演变</h2><h3 id="tcp-的特点" tabindex="-1"><a class="header-anchor" href="#tcp-的特点" aria-hidden="true">#</a> TCP 的特点</h3><ul><li>面向连接</li><li>可靠</li><li>基于字节流</li></ul><p>字节流可以理解为一个双向的通道里流淌的数据，这个数据其实就是常说的二进制数据，简单来说就是一大堆 01 串</p><p>纯裸 TCP 连接的 01 串之间是没有任何边界的，不知道到哪个地方才算一条消息</p><p>这就是所谓的粘包问题</p><h3 id="加入自定义规则" tabindex="-1"><a class="header-anchor" href="#加入自定义规则" aria-hidden="true">#</a> 加入自定义规则</h3><p>加入自定义规则用于区分消息边界，将每一条要发送的数据都包装一下</p><p>比如加入消息头，在消息头中说明一个完整的包长度是多少，根据这个长度可以继续接收消息，截取出来就是一条完整的消息</p><p>每个使用 TCP 的项目都可能会定义一套类似这样的协议</p><h2 id="有-http-为什么还要有-rpc" tabindex="-1"><a class="header-anchor" href="#有-http-为什么还要有-rpc" aria-hidden="true">#</a> 有 HTTP 为什么还要有 RPC</h2><p>TCP 产生于 70 年代，HTTP 提出于 90 年代，而 RPC 起源于 80 年代</p><p>所以是先有的 RPC，再有的 HTTP</p><p>我们先前说了，厂家都可以实现自定义的基于 TCP 的协议</p><p>现在电脑上装的各种软件，其实都是一个个客户端，需要和服务端建立连接收发消息，此时都会用到应用层协议，在这种 CS（Client-Server） 架构下，它们可以使用自家规定的 RPC 协议，因为他只管连自家的服务器就好了</p><p>但是有个软件不同，他就是浏览器 Browser，它需要访问各个公司的网站服务器，所以需要一个统一的标准，不然没法交流，HTTP 应运而生</p><p>RPC 一般用于公司内部各个微服务之间的通讯</p><h2 id="http-和-rpc-的区别" tabindex="-1"><a class="header-anchor" href="#http-和-rpc-的区别" aria-hidden="true">#</a> HTTP 和 RPC 的区别</h2><ul><li><strong>服务发现</strong>：HTTP 可以根据域名解析服务 DNS 找到对应的 IP，RPC 一般需要额外搭建一个中间服务器，比如 Consul、Eureka、Redis，来寻找对应服务的 IP</li><li><strong>传输内容</strong>：HTTP 一般采用 Json、Xml 来进行序列化和反序列化，而 RPC 一般使用 Protobuf、hessian 等序列化协议，传输更快，性能更强</li></ul>',25),i=[h];function n(o,c){return r(),a("div",null,i)}const P=e(p,[["render",n],["__file","为什么有了HTTP还要有RPC？.html.vue"]]);export{P as default};
