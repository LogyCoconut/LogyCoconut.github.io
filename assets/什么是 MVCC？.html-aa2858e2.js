import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as l,c as r,a as e,b as d,d as t,f as n}from"./app-19bdab2f.js";const a={},_=e("code",null,"MySQL",-1),s=e("code",null,"innodb",-1),p=e("br",null,null,-1),u={href:"https://relph1119.github.io/mysql-learning-notes/#/mysql/24-%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%9A%E5%B9%85%E9%9D%A2%E5%AD%94-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC",target:"_blank",rel:"noopener noreferrer"},h=n('<h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h3><p><code>MVCC</code>（<code>Multi-Version Concurrency Control</code> ，多版本并发控制）<br> 指的是在 <code>RC</code>、<code>RR</code> 隔离级别下执行普通 <code>SELECT</code> 操作时访问记录的版本链的过程，这样子可以使不同事务的 <code>读-写</code>、<code>写-读</code> 操作并发执行，从而提高系统性能</p><h3 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理" aria-hidden="true">#</a> 实现原理</h3><p>核心就在于 <code>undo log</code> 和 <code>ReadView</code>（一致性视图）</p><ul><li>通过<code> undo log</code> 来保存多版本的数据</li><li>通过 <code>ReadView</code> 保存当前活跃的事务列表</li></ul><p>首先我们知道使用 <code>innodb</code> 引擎的表中，它的聚簇索引记录会包含 3 个隐藏列</p><ul><li><code>row_id</code>: 非必需，表中如果存在主键或非 <code>Null</code> 的 <code>Unique</code> 键时不包含：</li><li><code>trx_id</code>：当有事务对某条聚簇索引记录进行改动时，会把该事务的<code>事务 id</code> 赋值给 <code>trx_id</code></li><li><code>roll_pointer</code>：每次对聚簇索引记录进行改动时，都会把旧的版本写入到 <code>undo 日志</code> 中，通过 <code>roll_pointer</code> 这个指针就可以找到该记录修改前的信息<br><em>行的每一次改动都会生成 <code>undo log</code>，久而久之，就会形成一条版本链</em><br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231221143106.png" alt="图片来自 《MySQL是怎么运行的：从根儿上理解 MySQL》" loading="lazy"></li></ul><p>而 <code>ReadView</code> 呢，它最主要的目的就是<strong>判断版本链中的哪个版本是当前事务可见的</strong><br> 它包含 4 个重要的内容</p><ul><li><code>m_ids</code>：生成 <code>ReadView</code> 时，活跃的读写事务的<code>事务 id</code> 列表</li><li><code>min_trx_id</code>：生成 <code>ReadView</code> 时，活跃的读写事务中最小的 <code>事务 id</code>，也就是 <code>m_ids</code> 的最新值</li><li><code>max_trx_id</code>：生成 <code>ReadView</code> 时，系统应该分配给下一个事务的 <code>id</code> 值<br> max_trx_id并不是m_ids中的最大值</li><li><code>creator_trx_id</code>：生成该 <code>ReadView</code> 的事务的 <code>事务 id</code><br> 只有在对表中的记录做改动时（执行 INSERT、DELETE、UPDATE 这些语句时）才会为事务分配事务 id，否则在一个只读事务中的事务 id 值都默认为 0<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231221144107.png" alt="image.png" loading="lazy"></li></ul><p>在执行 <code>SELECT</code> 语句时，<code>innodb</code> 引擎会生成一个 <code>ReadView</code>，随后按照特定的规则决定具体能看到数据的哪个版本</p><ul><li>如果被访问记录的 <code>trx_id</code> 等于 <code>creator_trx_id</code>，则意味着当前事务在访问自己修改过的版本，可以被当前事务访问</li><li>如果被访问记录的 <code>trx_id</code> 小于 <code>min_trx_id</code>，则意味着在查询前事务已经提交，可以被当前事务访问</li><li>如果被访问记录的 <code>trx_id</code> 大于等于 <code>max_trx_id</code>，则意味着在生成 <code>ReaView</code> 后事务才开启，不可以被当前事务访问</li><li>如果被访问记录的 <code>trx_id</code> 在 <code>min_trx_id</code> 与 <code>max_trx_id</code> 之间 <ul><li>在 <code>m_ids</code> 中，事务仍然活跃，不能被访问</li><li>不在 <code>m_ids</code> 中，事务已经被提交，可以被访问</li></ul></li></ul><p>按照这个规则，如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到上一个版本的数据，继续按照上述规则判断可见性，直到最后一个版本</p><h3 id="rc-和-rr-事务隔离级别的区别" tabindex="-1"><a class="header-anchor" href="#rc-和-rr-事务隔离级别的区别" aria-hidden="true">#</a> RC 和 RR 事务隔离级别的区别</h3><p>直接说结论</p><ul><li><code>RC</code>：每次读取数据前都生成一个 <code>ReadView</code></li><li><code>RR</code>：只在事务第一次执行查询语句时才会生成一个 <code>ReadView</code></li></ul><p>所以，<code>RR</code> 隔离级别下，每次查询数据时用的都是同一个 <code>ReadView</code>，才能做到可重复读<br> 而在 <code>RC</code> 隔离级别下，每次查询时，都可能有其他事务正常提交，导致 <code>ReadView</code> 中的 <code>max_trx_id</code> ，<code>m_ids</code> 发生变化，于是可以读取到已经提交的数据</p>',16);function m(E,x){const o=i("ExternalLinkIcon");return l(),r("div",null,[e("blockquote",null,[e("p",null,[d("针对 "),_,d(" 数据库的 "),s,d(" 引擎"),p,d(" 详细分析请看《MySQL 是怎么运行的：从根儿上理解 MySQL》中的 "),e("a",u,[d("MVCC 部分"),t(o)])])]),h])}const g=c(a,[["render",m],["__file","什么是 MVCC？.html.vue"]]);export{g as default};
