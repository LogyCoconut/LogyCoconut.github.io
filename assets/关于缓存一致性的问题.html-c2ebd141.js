import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as d,f as i}from"./app-0505bdf9.js";const r={},o=i('<h1 id="对于缓存的更新-目前主要有两种策略" tabindex="-1"><a class="header-anchor" href="#对于缓存的更新-目前主要有两种策略" aria-hidden="true">#</a> 对于缓存的更新，目前主要有两种策略</h1><blockquote><p>缓存一致性问题往往发生在 <code>MySQL</code> 和 <code>Redis</code> 中<br> 在数据变更过程中，因为并发、系统故障等问题导致数据、缓存更新不一致</p></blockquote><h3 id="缓存更新策略" tabindex="-1"><a class="header-anchor" href="#缓存更新策略" aria-hidden="true">#</a> 缓存更新策略</h3><p>对于缓存的更新，目前主要有两种策略</p><h4 id="超时剔除策略" tabindex="-1"><a class="header-anchor" href="#超时剔除策略" aria-hidden="true">#</a> 超时剔除策略</h4><blockquote><p>适用于低一致性需求，很少发生变更的数据</p></blockquote><p>比方说将数据存在 <code>Redis</code> 中，并设置 <code>ttl</code><br> 读请求到来时发现数据过期后，重新去 <code>MySQL</code> 中查询并塞入缓存</p><h4 id="主动更新策略" tabindex="-1"><a class="header-anchor" href="#主动更新策略" aria-hidden="true">#</a> 主动更新策略</h4><blockquote><p>适用于高一致性需求，常发生变更的数据<br> 超时剔除作为兜底</p></blockquote><p>数据发生变更后，主动发起对缓存的修改（更新或删除），可以通过异步线程、MQ 等方式</p><h3 id="操作类型" tabindex="-1"><a class="header-anchor" href="#操作类型" aria-hidden="true">#</a> 操作类型</h3><h4 id="读操作-读缓存" tabindex="-1"><a class="header-anchor" href="#读操作-读缓存" aria-hidden="true">#</a> 读操作（读缓存）</h4><ul><li><p>缓存命中，直接返回</p></li><li><p>缓存未命中，查库然后更新缓存</p></li></ul><h4 id="写操作-写缓存" tabindex="-1"><a class="header-anchor" href="#写操作-写缓存" aria-hidden="true">#</a> 写操作（写缓存）</h4><ul><li><p>更新缓存？删除缓存？<br> 肯定是选择删除缓存！</p></li><li><p>先删除缓存，后更新数据库<br> 会存在并发场景下更新数据后依旧读取老数据的问题<br> 可以使用<strong>延迟双删</strong>策略<br><em>就是先删缓存，再更新数据库，然后等线程 sleep 一会再删一遍缓存</em></p></li><li><p>先更新数据库，后删除缓存<br> 这个会存在并发问题吗？会，但是概率太低，几乎不可能</p></li></ul><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231218173904.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p><em>在这种情况下，才会出现读取到老数据的情况</em></p><p>但是一般情况下，写操作的请求时间往往会比读操作长，在 3-6 的间隙里做不完这么多事情</p><h3 id="为什么要删除缓存而不是更新缓存" tabindex="-1"><a class="header-anchor" href="#为什么要删除缓存而不是更新缓存" aria-hidden="true">#</a> 为什么要删除缓存而不是更新缓存？</h3><ul><li><p>更新缓存会涉及到很多无用操作，很多时候 <code>Redis</code> 中存储的数据和 <code>MySQL</code> 中并不是一一对应的，而是通过处理后才写入到 <code>Redis</code> 中</p></li><li><p>缓存更新后并不会立马被访问到，这时 <code>Redis</code> 中就会存放这一份冗余的数据，会造成一定的浪费</p></li></ul><h3 id="先更新数据库-再删除缓存-一个操作成功-一个操作失败怎么办" tabindex="-1"><a class="header-anchor" href="#先更新数据库-再删除缓存-一个操作成功-一个操作失败怎么办" aria-hidden="true">#</a> 先更新数据库，再删除缓存，一个操作成功，一个操作失败怎么办？</h3><p>这是由于系统故障导致的一致性问题</p><p><strong>解决方案</strong></p><ul><li><p>可以使用消息队列，更新数据库成功后往消息队列发消息，消费到消息后再删除缓存</p></li><li><p>订阅数据库变更日志 <code>binlog</code>（消息队列的进阶版，不用侵入到业务代码，比如 <code>canal</code>）</p></li></ul><p>两种方案的本质都是<strong>重试</strong></p>',25),c=[o];function h(t,l){return a(),d("div",null,c)}const s=e(r,[["render",h],["__file","关于缓存一致性的问题.html.vue"]]);export{s as default};
