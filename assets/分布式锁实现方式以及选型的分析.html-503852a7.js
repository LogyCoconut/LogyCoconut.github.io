const e=JSON.parse('{"key":"v-68fe0a4a","path":"/Resource/staged/SeniorDevelopment/Redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E9%80%89%E5%9E%8B%E7%9A%84%E5%88%86%E6%9E%90.html","title":"to be perfected","lang":"zh-CN","frontmatter":{"title":"to be perfected","index":false,"date":"2023-03-11T00:00:00.000Z","tag":["Redis"],"description":"简单说一下锁 锁的几个基本条件 锁必须是互斥的，即在任何时候只能有一个线程持有锁 锁必须是可重入的，即如果一个线程已经持有了锁，那么它可以多次获取锁儿不会发生死锁 锁必须是安全的，即如果一个线程获得了锁，那么即使崩溃或失去连接，锁也必须释放 分布式锁的几个条件 高性能：分布式锁可能会有很多服务器来获取，所以一定要保证锁能够高效地获取和释放，不然锁又会成为一个瓶颈 高可用：不能因为某一个分布式锁获取的服务不可用，导致所有服务都拿不到或者释放锁 锁失效机制：假设某个应用获取到锁之后，一直没有释放锁，可能服务本身已经挂掉了。不能一直不释放，导致其他服务一直获取不到锁 非阻塞特性：在某个服务来获取锁时，假设该锁已经被另一个服务获取，要能直接返回失败，不能一直等待","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/Resource/staged/SeniorDevelopment/Redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E9%80%89%E5%9E%8B%E7%9A%84%E5%88%86%E6%9E%90.html"}],["meta",{"property":"og:title","content":"to be perfected"}],["meta",{"property":"og:description","content":"简单说一下锁 锁的几个基本条件 锁必须是互斥的，即在任何时候只能有一个线程持有锁 锁必须是可重入的，即如果一个线程已经持有了锁，那么它可以多次获取锁儿不会发生死锁 锁必须是安全的，即如果一个线程获得了锁，那么即使崩溃或失去连接，锁也必须释放 分布式锁的几个条件 高性能：分布式锁可能会有很多服务器来获取，所以一定要保证锁能够高效地获取和释放，不然锁又会成为一个瓶颈 高可用：不能因为某一个分布式锁获取的服务不可用，导致所有服务都拿不到或者释放锁 锁失效机制：假设某个应用获取到锁之后，一直没有释放锁，可能服务本身已经挂掉了。不能一直不释放，导致其他服务一直获取不到锁 非阻塞特性：在某个服务来获取锁时，假设该锁已经被另一个服务获取，要能直接返回失败，不能一直等待"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-10T10:26:50.000Z"}],["meta",{"property":"article:author","content":"logycoconut"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:published_time","content":"2023-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-10T10:26:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"to be perfected\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-10T10:26:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://github.com/logycoconut\\"}]}"]]},"headers":[{"level":2,"title":"简单说一下锁","slug":"简单说一下锁","link":"#简单说一下锁","children":[{"level":3,"title":"锁的几个基本条件","slug":"锁的几个基本条件","link":"#锁的几个基本条件","children":[]},{"level":3,"title":"分布式锁的几个条件","slug":"分布式锁的几个条件","link":"#分布式锁的几个条件","children":[]}]},{"level":2,"title":"常见的分布式锁实现方式，如何进行选型","slug":"常见的分布式锁实现方式-如何进行选型","link":"#常见的分布式锁实现方式-如何进行选型","children":[{"level":3,"title":"基于 MySQL 实现分布式锁","slug":"基于-mysql-实现分布式锁","link":"#基于-mysql-实现分布式锁","children":[]},{"level":3,"title":"基于 Redis 的分布式锁实现方式","slug":"基于-redis-的分布式锁实现方式","link":"#基于-redis-的分布式锁实现方式","children":[]},{"level":3,"title":"基于 ZooKeeper 的分布式锁实现方式","slug":"基于-zookeeper-的分布式锁实现方式","link":"#基于-zookeeper-的分布式锁实现方式","children":[]}]}],"git":{"createdTime":1702204010000,"updatedTime":1702204010000,"contributors":[{"name":"logycoconut","email":"logycoconut@foxmail.com","commits":1}]},"readingTime":{"minutes":4.98,"words":1495},"filePathRelative":"Resource/staged/SeniorDevelopment/Redis/分布式锁实现方式以及选型的分析.md","localizedDate":"2023年3月11日","excerpt":"<h2> 简单说一下锁</h2>\\n<h3> 锁的几个基本条件</h3>\\n<ul>\\n<li>锁必须是<strong>互斥</strong>的，即在任何时候只能有一个线程持有锁</li>\\n<li>锁必须是<strong>可重入</strong>的，即如果一个线程已经持有了锁，那么它可以多次获取锁儿不会发生死锁</li>\\n<li>锁必须是<strong>安全</strong>的，即如果一个线程获得了锁，那么即使崩溃或失去连接，锁也必须释放</li>\\n</ul>\\n<h3> 分布式锁的几个条件</h3>\\n<ul>\\n<li><strong>高性能</strong>：分布式锁可能会有很多服务器来获取，所以一定要保证锁能够高效地获取和释放，不然锁又会成为一个瓶颈</li>\\n<li><strong>高可用</strong>：不能因为某一个分布式锁获取的服务不可用，导致所有服务都拿不到或者释放锁</li>\\n<li><strong>锁失效机制</strong>：假设某个应用获取到锁之后，一直没有释放锁，可能服务本身已经挂掉了。不能一直不释放，导致其他服务一直获取不到锁</li>\\n<li><strong>非阻塞特性</strong>：在某个服务来获取锁时，假设该锁已经被另一个服务获取，要能直接返回失败，不能一直等待</li>\\n</ul>","autoDesc":true}');export{e as data};
