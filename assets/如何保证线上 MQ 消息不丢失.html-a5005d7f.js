import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as a,f as l}from"./app-d43a649e.js";const t={},c=l('<h3 id="消息发送方式" tabindex="-1"><a class="header-anchor" href="#消息发送方式" aria-hidden="true">#</a> 消息发送方式</h3><ul><li>同步发送</li></ul><p>生产者向 MQ 发送消息，会阻塞线程，必须拿到 MQ 返回的结果后，整个过程才算结束</p><ul><li>异步发送</li></ul><p>先构建一个发送的任务，然后将任务丢到线程池中，最终结果是通过回调函数来得知</p><ul><li>OneWay 发送（单向）</li></ul><p>只负责发送请求，不需要关注结果</p><p>适用于 log 之类的消息，丢几条也没有关系</p><p>如果要保证消息不丢失，那就尽量不要选择这种方式</p><h3 id="什么时候会导致消息丢失" tabindex="-1"><a class="header-anchor" href="#什么时候会导致消息丢失" aria-hidden="true">#</a> 什么时候会导致消息丢失</h3><p>RocketMQ 消息是放在磁盘里面的，而且默认选择异步刷盘策略</p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/code/mq/20230224151635.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ul><li>异步刷盘的过程中，MQ 节点损坏，消息就落不了盘</li><li>磁盘坏了</li></ul><p>RocketMQ 采用一主多从的方式来备份消息，单个节点的磁盘数据坏了之后可以从其他节点中恢复</p>',14),o=[c];function n(r,_){return i(),a("div",null,o)}const s=e(t,[["render",n],["__file","如何保证线上 MQ 消息不丢失.html.vue"]]);export{s as default};
