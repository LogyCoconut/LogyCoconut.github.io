---
title: Java 集合
date: 2022-02-26
tag: [Java]
---

### ArrayList和LinkedList的区别

- **是否保证线程安全**：二者都是不同步的，都不保证线程安全

- **底层数据结构**：ArrayList底层是Object[]数组；LinkedList底层用的是双向链表

- **插入和删除是否受元素位置的影响**：

- ArrayList采用数组存储，所以插入和删除元素受元素位置的影响。比如：执行add(E e)方法时，会默认将指定的元素追加到此列表的末尾，这种时间复杂度就是O(1)，但是如果要在指定位置增加元素的话，时间复杂度就是O(n-i)，因为其余位置的元素都需要向后移动一位

- LinkedList采用链表存储，所以对于add(E e)方法来说，复杂度也近似O(1)，如果是要在指定位置插入元素的话，时间复杂度就近似O(n)，因为需要先移动到指定位置

- **是否支持快速随机访问**：ArrayList支持。快速随机访问就是通过元素的序号快速获取元素

- **内存空间占用**：ArrayList的空间浪费主要体现在list的结尾会预留一定的容量空间，而LinkedList的空间话费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继、直接前驱以及数据）

#### RandomAccess接口

ArrayList实现了此接口，RandomAccess接口只是一个标识，标识这个类具有随机访问的功能

在`binarySearch()`方法中，他会判断传入的list是否实现RandomAccess，如果是则调用`indexedBinarySearch()`方法，否则调用`iteratorBinarySearch()`

```
public static <T>
int binarySearch(List<? extends Comparable<? super T>> list, T key) {
    if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)
        return Collections.indexedBinarySearch(list, key);
    else
        return Collections.iteratorBinarySearch(list, key);
}
```

### ArrayList的扩容机制

#### ArrayList的构造函数

默认无参构造函数实际上初始化了一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组扩容为10

#### 代码解析（Java8）

// 添加元素
public boolean add(E e) {
ensureCapacityInternal(size + 1);  // Increments modCount!!
elementData[size++] = e;
return true;
}

private void ensureCapacityInternal(int minCapacity) {
ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
}

// 获取最小扩容量
private static int calculateCapacity(Object[] elementData, int minCapacity) {
if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
return Math.max(DEFAULT_CAPACITY, minCapacity);
}
return minCapacity;
}

// 判断是否需要扩容
private void ensureExplicitCapacity(int minCapacity) {
modCount++;

```
// overflow-conscious code
if (minCapacity - elementData.length > 0)
    grow(minCapacity);
```

}

// 核心扩容方法
private void grow(int minCapacity) {
// 记录旧容量
int oldCapacity = elementData.length;
// 计算新容量，结果等于旧容量的1.5倍
int newCapacity = oldCapacity + (oldCapacity >> 1);
if (newCapacity - minCapacity < 0)
newCapacity = minCapacity;
if (newCapacity - MAX_ARRAY_SIZE > 0)
newCapacity = hugeCapacity(minCapacity);
// minCapacity is usually close to size, so this is a win:
elementData = Arrays.copyOf(elementData, newCapacity);
}

#### System.arraycpoy()和Arrays.copyOf()方法

- Arrays.copyOf：主要用于给原数组扩容，内部会新建一个数组，并返回该数组
- System.arraycopy：将原数组拷贝到你自己定义的数组里或原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置

/**

- 复制数组
- @param src 源数组
- @param srcPos 源数组中的起始位置
- @param dest 目标数组
- @param destPos 目标数组中的起始位置
- @param length 要复制的数组元素的数量

*/
public static native void arraycopy(Object src,  int  srcPos,
Object dest, int destPos,
int length);

#### ensureCapacity和ensureCapacityInternal

顾名思义，ensureCapacityInternal是用户ArrayList内部调用的，ensureCapacity是给外部调用的。当我们需要大量插入元素时，可以先调用ensureCapacity方法扩容，这样可以减少在增加元素过程中重新分配的次数

### HashMap与HashTable的区别

1. 线程是否安全：HashMap是非线程安全的，HashTable是线程安全的，因为HashTable内部的方法基本都经过synchronized修饰

2. 效率：因为线程安全的问题，HashMap要比HashTable效率高一点

3. 对Null Key和Null Value的支持：HashMap支持，HashTable不允许Null，否则会抛出NullPointException

4. 初始容量大小和每次扩容大小的不同：

5. 如果不指定初始值

6. Hashtable的默认大小为11， 之后每次扩容为原来的2n+1

7. HashMap的默认大小为16，之后每次扩容为原来的2倍

8. 如果给定了初始值

9. HashTable会直接使用给定的初始值

10. HashMap会将其扩充为2的幂次方

11. 底层数据结构：jdk1.8之后的HashMap，当链表长度大于阈值（默认为8）时（将链表转换成红黑树之前会判断当前数组的长度，如果小于64，那么会选择数组扩容，而不是转换成红黑树），将链表转化成红黑树，以减少搜索时间

#### 保证HashMap的大小总为2的幂次方

这个方法的作用就是将当前数字-1后的结果n最高位后面的位都填充1，得到的最后结果+1就会将最高位又进1

**举个例子**

cap = 5

n = 4， 也既是00000100

它的最后结果就是00000111， 也就是7

最后+1进位，返回最终结果8

static final int tableSizeFor(int cap) {
int n = cap - 1;
n |= n >>> 1;
n |= n >>> 2;
n |= n >>> 4;
n |= n >>> 8;
n |= n >>> 16;
return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}

### HashMap和HashSet的区别

HashMap

HashSet

存储键值对

仅存储对象

调用put添加元素

调用add增加元素

使用键来计算hashCode

使用成员对象来计算hashCode

### HashMap的底层实现

- Java8之前

底层是数组和链表结合在一起使用的链表散列。HashMap通过key的hashCode经过扰动函数处理后得到hash值，然后通过`(n-1)&hash`计算当前元素存放的位置（这里的n指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同的话，直接覆盖，不相同的话就通过拉链法解决

**扰动函数：**其实就是HashMap的hash方法，使用hash方法也就是扰动函数是为了防止一些实现比较差的hashCode方法，换句话说，使用扰动函数之后可以减少碰撞

static final int hash(Object key) {
int h;
return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

**拉链法：**就是创建一个链表数组，数组中每一格就是一个链表，若遇到hash冲突，则将冲突的值加到链表中即可

![](https://cdn.nlark.com/yuque/0/2022/png/1792674/1646553870894-9f12997b-e6eb-44af-9633-8afa48351f75.png)

- Java8之后

当链表长度大于阈值时（默认为8），将链表转换为红黑树，以减少搜索时间（转换前会判断当前数组的长度，如果小于64，那么会选择先将数组扩容）

![](https://cdn.nlark.com/yuque/0/2022/png/1792674/1646554043505-d7814f47-4e72-4fe0-baac-edda767324c0.png)

### HashMap的长度为什么是2的幂次方

Hash值的范围在-2^31～2^31-1之间，前后加起来大概40亿的映射空间，这样的数组内存是放不下的，所以我们还需要对数组长度取模运算，得到的余数就是要存放的位置，也就是数组下标

计算方式就是 `hash%n`，但是如果除数是2的幂次方的话，那么`hash%n`就等价于`(n-1)&hash`。采用与操作相对于%操作来说会提高运算效率，这就解释了为什么HashMap的长度为什么是2的幂次方

### HashMap多线程操作导致死循环（Java8之前）

[JAVA HASHMAP的死循环](https://coolshell.cn/articles/9606.html)

### ConcurrentHashMap线程安全的具体实现方式

- JDK1.7

![](https://cdn.nlark.com/yuque/0/2022/png/1792674/1646558557818-b1756d84-8038-4624-b0ff-0db34cb7fc8c.png)

首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问

ConcurrentHashMap是由Segment和HashEntry组成

Segment实现了ReentrantLock，所以Segment时一种可重入锁

一个ConcurrentHashMap包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry的元素，当对HashEntry修改时，必须获得对应的Segment锁

- JDK1.8

![](https://cdn.nlark.com/yuque/0/2022/png/1792674/1646558579756-fcbf4af8-aca2-43c7-934c-2daa97a1c033.png)

ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构也是数组+链表/红黑树的形式，Java8在链表长度超过一定阈值时将链表(O(N))转换成红黑树（O(logN)）

synchronized只锁定当前链表或者红黑树的首节点，所以只要hash不冲突，就不会产生并发
